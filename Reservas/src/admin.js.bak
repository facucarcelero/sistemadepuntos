import { initializeApp } from "firebase/app";
import { getFirestore, collection, query, where, getDocs, doc, deleteDoc, updateDoc, getDoc, setDoc, serverTimestamp, onSnapshot, addDoc, orderBy, limit, startAfter } from "firebase/firestore";
import { getAuth, signInAnonymously } from "firebase/auth";
import { getMessaging, getToken, onMessage } from "firebase/messaging";
import { NOTIFICATION_CONFIG, createNotificationOptions } from "./config.js";
import { initializeSearchModal } from './cliente.js';

// Configuraci√≥n de Firebase usando variables de entorno Vite
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

const messaging = getMessaging(app);

const VAPID_KEY = "BNajMopvmxkuBroh5TYWc4ZAQjnRhRfdDeTNYPn6guoHF6aOrS-yXetEeguxhq5J1ANsD1CvxlJm_teh33DR7N0";

// Espera a que el Service Worker de Firebase est√© registrado antes de pedir el token
navigator.serviceWorker.ready.then((registration) => {
  getToken(messaging, { vapidKey: VAPID_KEY, serviceWorkerRegistration: registration })
    .then((currentToken) => {
      if (currentToken) {
        console.log('Token FCM:', currentToken);
        // Guardar el token en Firestore
        saveAdminToken(currentToken);
      } else {
        console.log('No se pudo obtener el token de FCM.');
      }
    })
    .catch((err) => {
      console.log('Error obteniendo token de FCM:', err);
    });
});

async function saveAdminToken(currentToken) {
  if (!currentToken) return;
  try {
    // Verificar si el token ya existe
    const q = query(collection(db, "adminTokens"), where("token", "==", currentToken));
    const snapshot = await getDocs(q);
    if (snapshot.empty) {
      await setDoc(doc(db, "adminTokens", currentToken), {
        token: currentToken,
        activo: true
      });
      console.log("Token guardado en Firestore");
    } else {
      console.log("Token ya existe en Firestore, no se guarda duplicado");
    }
  } catch (e) {
    console.error("Error guardando token en Firestore:", e);
  }
}

// Recibe mensajes cuando la app est√° en primer plano
onMessage(messaging, (payload) => {
  console.log('Mensaje recibido en primer plano:', payload);
  // Puedes mostrar una notificaci√≥n aqu√≠ si quieres
});

// ========== HELPERS ==========
const getEl = (id) => document.getElementById(id);



/**
 * Calcula el monto de se√±a seg√∫n la cantidad de comensales
 */
function calcularMontoSenia(diners) {
  if (diners >= 60) return 100000;
  if (diners >= 30) return 50000;
  if (diners >= 10) return 25000;
  return 10000;
}

/**
 * Detecta si el usuario est√° en un dispositivo m√≥vil
 */
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
         window.innerWidth <= 768;
}

/**
 * Detecta espec√≠ficamente Samsung Galaxy
 */
function isSamsungGalaxy() {
  return /Samsung|SM-/i.test(navigator.userAgent);
}

// ========== INICIALIZACI√ìN DEL PANEL ==========
function initializeAdminPanel() {
    // Configuraci√≥n de fecha base y eventos de filtros
    const dateFilter = getEl('dateFilter');
    if (dateFilter) {
        // Usar fecha local en lugar de UTC para evitar problemas de zona horaria
        const now = new Date();
        const today = now.getFullYear() + '-' + 
                     String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                     String(now.getDate()).padStart(2, '0');
        // Solo asignar la fecha si el usuario no ha seleccionado una
        if (!dateFilter.value) {
            dateFilter.value = today;
            console.log(`üìÖ Fecha inicial configurada: ${today}`);
        } else {
            console.log(`üìÖ Fecha ya seleccionada por el usuario: ${dateFilter.value}`);
        }
        dateFilter.addEventListener('change', () => {
            currentFilter = 'all';
            updateFilterCardStyles('all');
            cleanupFirestoreListener();
            setupFirestoreListener();
            fetchAdminReservations(dateFilter.value, 'daily');
        });
        // Ejecutar consulta inicial
        fetchAdminReservations(dateFilter.value || today, 'daily');
    }

    // Bot√≥n refrescar
    const refreshButton = getEl('refresh-button');
    if (refreshButton) {
        refreshButton.onclick = () => {
            // Limpiar estado antes de refrescar
            reinitializeSystem();
            
            const dateFilter = getEl('dateFilter');
            const periodSelector = getEl('periodSelector');
            if (dateFilter && dateFilter.value) {
                fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
            }
            // Agregar animaci√≥n de rotaci√≥n
            refreshButton.style.transform = 'rotate(360deg)';
            setTimeout(() => {
                refreshButton.style.transform = 'rotate(0deg)';
            }, 500);
        };
    }

    // Bot√≥n forzar actualizaci√≥n completa
    const forceRefreshButton = getEl('force-refresh-button');
    if (forceRefreshButton) {
        forceRefreshButton.onclick = async () => {
            // Agregar animaci√≥n de escala
            forceRefreshButton.style.transform = 'scale(1.2)';
            setTimeout(() => {
                forceRefreshButton.style.transform = 'scale(1)';
            }, 200);
            
            await forceRefreshReservations();
        };
    }
    


    // Filtros por per√≠odo
    const periodSelector = getEl('periodSelector');
    const customDateRangeInputs = getEl('customDateRangeInputs');
    const dateRangeStart = getEl('dateRangeStart');
    const dateRangeEnd = getEl('dateRangeEnd');
    const periodDisplay = getEl('periodDisplay');
    const selectedPeriodRangeDisplay = getEl('selectedPeriodRangeDisplay');

    if (periodSelector) {
        periodSelector.addEventListener('change', function() {
            const selectedPeriod = this.value;
            const dateFilter = getEl('dateFilter');
            if (selectedPeriod === 'custom') {
                if (customDateRangeInputs) customDateRangeInputs.classList.remove('hidden');
            } else {
                if (customDateRangeInputs) customDateRangeInputs.classList.add('hidden');
                if (periodDisplay) {
                    const periodTexts = {
                        'daily': 'Hoy',
                        'weekly': 'Esta semana',
                        'monthly': 'Este mes',
                        'yearly': 'Este a√±o'
                    };
                    periodDisplay.textContent = periodTexts[selectedPeriod] || '';
                }
                if (dateFilter && dateFilter.value) {
                    fetchAdminReservations(dateFilter.value, selectedPeriod);
                }
            }
        });
        if (dateRangeStart && dateRangeEnd) {
            const handleCustomDateChange = () => {
                if (dateRangeStart.value && dateRangeEnd.value) {
                    if (selectedPeriodRangeDisplay) {
                        const startFormatted = new Date(dateRangeStart.value + 'T00:00:00').toLocaleDateString('es-AR');
                        const endFormatted = new Date(dateRangeEnd.value + 'T00:00:00').toLocaleDateString('es-AR');
                        selectedPeriodRangeDisplay.textContent = `Per√≠odo: ${startFormatted} a ${endFormatted}`;
                    }
                    fetchAdminReservations(null, 'custom');
                }
            };
            dateRangeStart.addEventListener('change', handleCustomDateChange);
            dateRangeEnd.addEventListener('change', handleCustomDateChange);
        }
    }

    // Configurar b√∫squeda y exportar
    setupAdminSearchAndExport();
    
    // Configurar eventos de acciones
    setupAdminActionEvents();
    
    // Configurar b√∫squeda avanzada
    setupAdminAdvancedSearch();
    
    // Registrar Service Worker para notificaciones del admin
    registerAdminServiceWorker().catch(error => {
        console.error('‚ùå [ADMIN] Error registrando Service Worker:', error);
    });

    // Inicializar el listener de notificaciones del cliente
    setupAdminNotificationListener();
    
    // Inicializar sistema de recordatorios autom√°ticos
    setupAdminReminderSystem();

    // Configurar notificaciones en segundo plano para Samsung
    setupBackgroundNotifications();

    // Detectar dispositivo y mostrar informaci√≥n
    if (isMobileDevice()) {
        console.log('üì± [ADMIN_MOBILE] Dispositivo m√≥vil detectado');
        if (isSamsungGalaxy()) {
            console.log('üì± [ADMIN_MOBILE] Samsung Galaxy detectado - Notificaciones optimizadas activadas');
        }
    } else {
        console.log('üñ•Ô∏è [ADMIN] Dispositivo desktop detectado');
    }

    // Inicializar componentes del admin
    setupAdminActionEvents();
    setupAdminSearchAndExport();
    setupAdminAdvancedSearch();
    setupAddReservationButton();
    setupSpecialDaysModal();
    setupEditModal();
    setupCancellationsHistoryModal();
    
    // Inicializar sistema de asistencias por tiempo
    initializeAttendanceSystem();
    
    // Inicializar sistema de filtros por turno
    setupTurnFilters();
    
    // Asegurar que el indicador de rol se muestre si hay sesi√≥n activa
    if (currentUserRole) {
        const color = currentUserRole === 'observer' ? 'blue' : 'green';
        const role = currentUserRole === 'observer' ? 'Observador' : 'Administrador';
        showRoleIndicator(role, color);
    }
    
    // Limpiar estado inicial
    allReservations = [];
    console.log('üîÑ Estado inicial limpiado');
}

// ========== B√öSQUEDA Y EXPORTAR ==========
function setupAdminSearchAndExport() {
    // B√∫squeda en reservas
    const searchInput = getEl('admin-search-input');
    if (searchInput) {
        searchInput.oninput = function() {
            const term = this.value.trim().toLowerCase();
            if (window._adminReservationsFiltered) {
                const filtered = window._adminReservationsFiltered.filter(r =>
                    Object.values(r).some(val => (val + '').toLowerCase().includes(term))
                );
                updateAdminUI(filtered);
            }
        };
    }

    // Exportar a Excel
    const exportExcelBtn = getEl('export-excel-btn');
    if (exportExcelBtn) {
        exportExcelBtn.onclick = exportToExcel;
    }
}

// ========== EVENTOS DE ACCIONES SOBRE RESERVAS ==========
function setupAdminActionEvents() {
    document.addEventListener('click', (e) => {
        const button = e.target.closest('.action-button');
        if (!button) return;

        if (button.classList.contains('edit-res-btn')) {
            // Refuerzo: solo abrir modal si firestoreId es v√°lido (20 caracteres)
            const firestoreId = button.dataset.firestoreId;
            if (firestoreId && firestoreId.length === 20) {
                openEditModal(firestoreId);
            } // else {
                // console.warn('[ADMIN] Intento de abrir modal con id inv√°lido:', firestoreId || button.dataset.id);
            // }
        } else if (button.classList.contains('delete-res-btn')) {
            const reservationId = button.dataset.id;
            if (reservationId) {
                // Buscar los datos de la reserva para mostrar en el modal
                const reservationRow = button.closest('tr');
                let reservationData = {
                    id: reservationId // Siempre incluir el ID
                };
                
                if (reservationRow) {
                    // Intentar obtener datos de la fila de la tabla
                    const nameCell = reservationRow.querySelector('td:nth-child(1)');
                    const dateCell = reservationRow.querySelector('td:nth-child(3)');
                    const timeCell = reservationRow.querySelector('td:nth-child(4)');
                    const dinersCell = reservationRow.querySelector('td:nth-child(5)');
                    
                    if (nameCell) reservationData.name = nameCell.textContent?.trim();
                    if (dateCell) reservationData.date = dateCell.textContent?.trim();
                    if (timeCell) reservationData.time = timeCell.textContent?.trim();
                    if (dinersCell) reservationData.diners = dinersCell.textContent?.trim();
                }
                
                showAdminDeleteModalVisual(reservationData, async (reservation) => {
                    try {
                        await deleteReservation(reservation.id, reservation);
                    } catch (error) {
                        alert('Error al eliminar la reserva.');
                    }
                });
            }
        } else if (button.classList.contains('refresh-payment-btn')) {
            const reservationId = button.dataset.id;
            const mpPaymentId = button.dataset.mpId;
            if (reservationId && mpPaymentId) {
                refreshPaymentStatus(reservationId, mpPaymentId);
            }
        }
        // Bot√≥n de forzar aprobaci√≥n eliminado para evitar errores y dejar el c√≥digo limpio
    });
}

// ========== OBTENER Y FILTRAR RESERVAS ==========
async function fetchAdminReservations(dateString, periodType = 'daily') {
  showReservationsLoader();
  if (!db) return;
  try {
    let queryConstraints = [];
    let periodInfo = '';
    let titleDate = '';
    if (periodType === 'daily' && dateString) {
      queryConstraints.push(where('date', '==', dateString));
      const [year, month, day] = dateString.split('-');
      titleDate = new Date(year, month - 1, day).toLocaleDateString('es-AR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
      periodInfo = `D√≠a: ${titleDate}`;
    } else if (periodType === 'weekly' && dateString) {
      const baseDate = new Date(dateString + 'T00:00:00');
      const startOfWeek = new Date(baseDate);
      startOfWeek.setDate(baseDate.getDate() - baseDate.getDay());
      const endOfWeek = new Date(startOfWeek);
      endOfWeek.setDate(startOfWeek.getDate() + 6);
      const startDate = startOfWeek.toISOString().split('T')[0];
      const endDate = endOfWeek.toISOString().split('T')[0];
      queryConstraints.push(where('date', '>=', startDate));
      queryConstraints.push(where('date', '<=', endDate));
      titleDate = `Semana del ${startDate} al ${endDate}`;
      periodInfo = `Semana: ${startDate} a ${endDate}`;
    } else if (periodType === 'monthly' && dateString) {
      const [year, month] = dateString.split('-');
      const startDate = `${year}-${month}-01`;
      const lastDay = new Date(year, month, 0).getDate();
      const endDate = `${year}-${month}-${lastDay}`;
      queryConstraints.push(where('date', '>=', startDate));
      queryConstraints.push(where('date', '<=', endDate));
      const monthName = new Date(year, month - 1, 1).toLocaleDateString('es-AR', { month: 'long', year: 'numeric' });
      titleDate = monthName;
      periodInfo = `Mes: ${monthName}`;
    } else if (periodType === 'yearly' && dateString) {
      const year = dateString.substring(0, 4);
      const startDate = `${year}-01-01`;
      const endDate = `${year}-12-31`;
      queryConstraints.push(where('date', '>=', startDate));
      queryConstraints.push(where('date', '<=', endDate));
      titleDate = `A√±o ${year}`;
      periodInfo = `A√±o: ${year}`;
    } else if (periodType === 'custom') {
      const dateRangeStart = getEl('dateRangeStart');
      const dateRangeEnd = getEl('dateRangeEnd');
      if (dateRangeStart && dateRangeEnd && dateRangeStart.value && dateRangeEnd.value) {
        queryConstraints.push(where('date', '>=', dateRangeStart.value));
        queryConstraints.push(where('date', '<=', dateRangeEnd.value));
        const startFormatted = new Date(dateRangeStart.value + 'T00:00:00').toLocaleDateString('es-AR');
        const endFormatted = new Date(dateRangeEnd.value + 'T00:00:00').toLocaleDateString('es-AR');
        titleDate = `${startFormatted} a ${endFormatted}`;
        periodInfo = `Per√≠odo: ${startFormatted} a ${endFormatted}`;
      } else {
        return;
      }
    } else {
      return;
    }
    const q = query(collection(db, 'reservations'), ...queryConstraints);
    if (window._adminReservationsUnsub) window._adminReservationsUnsub();
    window._adminReservationsUnsub = onSnapshot(q, (snapshot) => {
      const reservations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      const filteredReservations = reservations.filter(res => res.name && res.date && res.time);
      filteredReservations.sort((a, b) => {
        const dateA = new Date(`${a.date}T${a.time}`);
        const dateB = new Date(`${b.date}T${b.time}`);
        return dateA - dateB;
      });
      updateAdminUI(filteredReservations, titleDate, periodInfo);
    }, (error) => {
      updateAdminUI([], 'Error', 'Error al cargar datos');
    });
    return;
  } catch (error) {
    updateAdminUI([], 'Error', 'Error al cargar datos');
  }
}

// ========== RENDERIZADO DE LA UI DEL PANEL DE ADMINISTRACI√ìN ==========
function updateAdminUI(reservations, titleDate = '', periodInfo = '') {
    // Definir variables de totales SIEMPRE al inicio
    let dinersDay = 0, dinersLunch = 0, dinersDinner = 0;
    const isMobile = window.innerWidth < 768;
    const body = getEl('reservationsTableBody');
    const mobileDiv = getEl('reservasCardsMobile');
    if (!body || !mobileDiv) {
        console.error('Elemento reservationsTableBody o reservasCardsMobile no encontrado');
        return;
    }
    
    // Guardar las reservas sin filtrar para los filtros
    allReservations = [...reservations]; // SIEMPRE reemplazar, nunca preservar
    console.log(`Reservas guardadas para filtros: ${allReservations.length}`);
    
    // Filtrar duplicados por firestoreId o id real
    const uniqueReservationsMap = new Map();
    reservations.forEach(res => {
        const uniqueId = res.firestoreId || res.id;
        if (!uniqueReservationsMap.has(uniqueId)) {
            uniqueReservationsMap.set(uniqueId, res);
        }
    });
    const uniqueReservations = Array.from(uniqueReservationsMap.values());

    if (isMobile) {
        // Renderizar tarjetas en el div m√≥vil (dise√±o responsive mejorado)
        uniqueReservations.forEach(res => {
            const d = parseInt(res.diners) || 0;
            const turn = res.turn || calcularTurnoPorHora(res.time);
            const paymentStatus = res.paymentStatus || 'no especificado';
            dinersDay += d;
            if (turn.toLowerCase() === 'almuerzo') dinersLunch += d;
            else if (turn.toLowerCase() === 'cena') dinersDinner += d;
            
            let paymentStatusClass = '';
            let paymentStatusText = '';
            let createdByText = '';
            let createdByClass = '';
            
            // Determinar texto y clase del estado de pago
            if (paymentStatus === 'approved' || paymentStatus === 'confirmed') {
                paymentStatusClass = 'bg-green-100 text-green-800';
                paymentStatusText = 'Pagada';
            } else if (paymentStatus === 'pagado-manual') {
                paymentStatusClass = 'bg-blue-100 text-blue-800';
                paymentStatusText = 'Pagado Manual';
            } else if (paymentStatus === 'manual') {
                paymentStatusClass = 'bg-orange-100 text-orange-800';
                paymentStatusText = 'Manual';
            } else if (paymentStatus === 'pending') {
                paymentStatusClass = 'bg-yellow-100 text-yellow-800';
                paymentStatusText = 'Pendiente';
            } else if (paymentStatus === 'rejected') {
                paymentStatusClass = 'bg-red-100 text-red-800';
                paymentStatusText = 'Rechazada';
            } else {
                paymentStatusClass = 'bg-gray-100 text-gray-700';
                paymentStatusText = 'Desconocido';
            }
            
            // Determinar texto y clase del creador
            if (res.createdBy === 'admin') {
                createdByText = 'Admin';
                createdByClass = 'bg-purple-100 text-purple-800';
            } else if (res.createdBy === 'observador') {
                createdByText = 'Observador';
                createdByClass = 'bg-indigo-100 text-indigo-800';
            } else if (res.createdBy === 'cliente') {
                createdByText = 'Cliente';
                createdByClass = 'bg-green-100 text-green-800';
            } else {
                createdByText = 'Sistema';
                createdByClass = 'bg-gray-100 text-gray-700';
            }
            // Determinar el estado de asistencia y color de la tarjeta
            const attendanceStatus = res.attendanceStatus;
            const attendanceColor = getAttendanceStatusColor(attendanceStatus);
            const attendanceText = attendanceStatus ? getAttendanceStatusText(attendanceStatus) : '';
            
            // Aplicar color de fondo solo si hay estado de asistencia marcado
            let cardBorderClass = attendanceStatus ? ATTENDANCE_COLORS[attendanceStatus] : 'border-gray-200';
            
            const card = document.createElement('div');
            card.className = `mb-4 bg-white rounded-xl shadow-lg border-2 ${cardBorderClass} overflow-hidden`;
            card.innerHTML = `
                <div class="bg-gray-50 px-4 py-3 border-b">
                    <div class="flex justify-between items-center">
                        <h3 class="font-bold text-lg text-gray-900">${res.name || 'Sin nombre'}</h3>
                        <div class="flex flex-col items-end gap-1">
                            <span class="px-2 py-1 text-xs font-semibold rounded-full ${paymentStatusClass}">${paymentStatusText}</span>
                            <span class="px-2 py-1 text-xs font-semibold rounded-full ${createdByClass}">${createdByText}</span>
                            ${attendanceStatus ? `<div class="text-xs text-gray-500" title="${attendanceText}">Estado: ${attendanceText}</div>` : ''}
                        </div>
                    </div>
                </div>
                <div class="p-4 space-y-2">
                    <div class="grid grid-cols-2 gap-2 text-sm">
                        <div><span class="font-medium text-gray-600">Tel√©fono:</span> ${res.phone || 'Sin tel√©fono'}</div>
                        <div><span class="font-medium text-gray-600">Fecha:</span> ${res.dateFormatted || res.date || 'Sin fecha'}</div>
                        <div><span class="font-medium text-gray-600">Hora:</span> ${res.time || '00:00'} hs</div>
                        <div><span class="font-medium text-gray-600">Comensales:</span> ${d}</div>
                        <div><span class="font-medium text-gray-600">Turno:</span> ${turn}</div>
                        ${res.area ? `<div><span class="font-medium text-gray-600">√Årea:</span> ${res.area}</div>` : ''}
                    </div>
                    ${res.notes ? `<div class="mt-2 p-2 bg-gray-50 rounded text-sm"><span class="font-medium text-gray-600">Notas:</span> ${res.notes}</div>` : ''}
                    ${res.depositAmount && res.paymentMethod ? `<div class="mt-2 p-2 bg-blue-50 rounded text-sm">
                        <span class="font-medium text-blue-600">Se√±a:</span> $${res.depositAmount.toLocaleString('es-AR')} - ${res.paymentMethod.charAt(0).toUpperCase() + res.paymentMethod.slice(1)}
                    </div>` : ''}
                </div>
                <div class="px-4 py-3 bg-gray-50 border-t">
                    <div class="flex flex-wrap gap-2 justify-center">
                        <button onclick="generarComprobantePDF({nombre: '${res.name || 'Cliente'}', fecha: '${res.date || new Date().toISOString().split('T')[0]}', monto: ${res.depositAmount || res.amount || calcularMontoSenia(res.diners) || 10000}, reservaId: '${res.id}', estado: '${paymentStatusText}', paymentId: '${res.paymentId || ''}', mpPaymentId: '${res.mpPaymentId || ''}', area: '${res.area || ''}', notes: '${res.notes || ''}', time: '${res.time || ''}', diners: '${res.diners || ''}', phone: '${res.phone || ''}', turn: '${res.turn || calcularTurnoPorHora(res.time)}', depositAmount: ${res.depositAmount || calcularMontoSenia(res.diners) || 10000}})" class="action-button p-2 text-gray-500 hover:text-gray-700 rounded-full hover:bg-gray-100 transition-colors" title="Descargar PDF">
                            <i class='ph ph-download-simple text-lg'></i>
                        </button>
                        ${res.firestoreId && res.firestoreId.length === 20 ? `<button data-firestore-id="${res.firestoreId}" class="action-button edit-res-btn admin-only p-2 text-blue-500 hover:text-blue-700 rounded-full hover:bg-blue-100 transition-colors" title="Editar">
                            <i class="ph ph-pencil-simple text-lg"></i>
                        </button>` : ''}
                        ${res.firestoreId && res.firestoreId.length === 20 ? `<button data-firestore-id="${res.firestoreId}" class="action-button delete-res-btn admin-only p-2 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100 transition-colors" title="Eliminar">
                            <i class="ph ph-trash text-lg"></i>
                        </button>` : ''}
                        ${res.mpPaymentId ? `<button data-id="${res.id}" data-mp-id="${res.mpPaymentId}" class="action-button refresh-payment-btn p-2 text-blue-500 hover:text-blue-700 rounded-full hover:bg-blue-100 transition-colors" title="Actualizar estado de pago">
                            <i class="ph ph-arrow-clockwise text-lg"></i>
                        </button>` : ''}
                        <!-- Comentado temporalmente - Bot√≥n de forzar aprobaci√≥n
                        ${paymentStatus === 'pending' ? `<button data-id="${res.id}" class="action-button force-approve-btn p-2 text-green-500 hover:text-green-700 rounded-full hover:bg-green-100 transition-colors" title="Forzar aprobaci√≥n">
                            <i class="ph ph-check-circle text-lg"></i>
                        </button>` : ''}
                        -->
                    </div>
                    <!-- Botones de Asistencia -->
                    <div class="mt-3 pt-3 border-t border-gray-200">
                        <div class="text-xs text-gray-600 mb-2 text-center">Control de Asistencia</div>
                        <div class="flex flex-wrap gap-2 justify-center">
                            ${generateAttendanceButtons(res)}
                        </div>
                    </div>
                </div>
            `;
            mobileDiv.appendChild(card);
        });
    } else {
        // Vista de escritorio (tabla)
        uniqueReservations.forEach(res => {
            const d = parseInt(res.diners) || 0;
            const turn = res.turn || calcularTurnoPorHora(res.time);
            const paymentStatus = res.paymentStatus || 'no especificado';
            dinersDay += d;
            if (turn.toLowerCase() === 'almuerzo') dinersLunch += d;
            else if (turn.toLowerCase() === 'cena') dinersDinner += d;
            
            let paymentStatusClass = '';
            let paymentStatusText = '';
            let createdByText = '';
            let createdByClass = '';
            
            // Determinar texto y clase del estado de pago
            if (paymentStatus === 'approved' || paymentStatus === 'confirmed') {
                paymentStatusClass = 'bg-green-100 text-green-800';
                paymentStatusText = 'Pagada';
            } else if (paymentStatus === 'pagado-manual') {
                paymentStatusClass = 'bg-blue-100 text-blue-800';
                paymentStatusText = 'Pagado Manual';
            } else if (paymentStatus === 'manual') {
                paymentStatusClass = 'bg-orange-100 text-orange-800';
                paymentStatusText = 'Manual';
            } else if (paymentStatus === 'pending') {
                paymentStatusClass = 'bg-yellow-100 text-yellow-800';
                paymentStatusText = 'Pendiente';
            } else if (paymentStatus === 'rejected') {
                paymentStatusClass = 'bg-red-100 text-red-800';
                paymentStatusText = 'Rechazada';
            } else {
                paymentStatusClass = 'bg-gray-100 text-gray-700';
                paymentStatusText = 'Desconocido';
            }
            
            // Determinar texto y clase del creador
            if (res.createdBy === 'admin') {
                createdByText = 'Admin';
                createdByClass = 'bg-purple-100 text-purple-800';
            } else if (res.createdBy === 'observador') {
                createdByText = 'Observador';
                createdByClass = 'bg-indigo-100 text-indigo-800';
            } else if (res.createdBy === 'cliente') {
                createdByText = 'Cliente';
                createdByClass = 'bg-green-100 text-green-800';
            } else {
                createdByText = 'Sistema';
                createdByClass = 'bg-gray-100 text-gray-700';
            }
            
            const row = body.insertRow();
            row.className = 'border-b hover:bg-gray-50 transition-colors';
            row.innerHTML = `
                <td data-label="Nombre" class="px-4 py-3 font-medium">${res.name || 'Sin nombre'}</td>
                <td data-label="Tel√©fono" class="px-4 py-3">${res.phone || 'Sin tel√©fono'}</td>
                <td data-label="Fecha" class="px-4 py-3">${res.date || 'Sin fecha'}</td>
                <td data-label="Hora" class="px-4 py-3">${res.time || '00:00'} hs</td>
                <td data-label="Comensales" class="px-4 py-3 font-bold text-lg md:text-base md:text-center">${d}</td>
                <td data-label="Turno" class="px-4 py-3">
                    <div class="flex flex-col items-start gap-1">
                        <span class="px-2 py-1 font-semibold leading-tight text-xs rounded-full ${turn.toLowerCase() === 'almuerzo' ? 'bg-amber-100 text-amber-800' : 'bg-indigo-100 text-indigo-800'}">${turn}</span>
                        <span class="px-2 py-1 font-semibold leading-tight text-xs rounded-full ${paymentStatusClass}">${paymentStatusText}</span>
                        <span class="px-2 py-1 font-semibold leading-tight text-xs rounded-full ${createdByClass}">${createdByText}</span>
                        ${res.depositAmount && res.paymentMethod ? `<span class="px-2 py-1 font-semibold leading-tight text-xs rounded-full bg-blue-100 text-blue-800">$${res.depositAmount.toLocaleString('es-AR')} - ${res.paymentMethod.charAt(0).toUpperCase() + res.paymentMethod.slice(1)}</span>` : ''}
                        <!-- Estado de Asistencia - Solo tooltip en el header -->
                        ${res.attendanceStatus ? `<div class="text-xs text-gray-500" title="${getAttendanceStatusText(res.attendanceStatus)}">Estado: ${getAttendanceStatusText(res.attendanceStatus)}</div>` : ''}
                    </div>
                </td>
                <td data-label="√Årea" class="px-4 py-3">${res.area || 'No especificada'}</td>
                <td data-label="Notas" class="px-4 py-3">${res.notes || ''}</td>
                <td class="actions-cell px-4 py-3 text-center">
                    <div class="flex items-center justify-center gap-1 flex-wrap">
                        <button onclick="generarComprobantePDF({nombre: '${res.name || 'Cliente'}', fecha: '${res.date || new Date().toISOString().split('T')[0]}', monto: ${res.depositAmount || res.amount || calcularMontoSenia(res.diners) || 10000}, reservaId: '${res.id}', estado: '${paymentStatusText}', paymentId: '${res.paymentId || ''}', mpPaymentId: '${res.mpPaymentId || ''}', area: '${res.area || ''}', notes: '${res.notes || ''}', time: '${res.time || ''}', diners: '${res.diners || ''}', phone: '${res.phone || ''}', turn: '${res.turn || calcularTurnoPorHora(res.time)}', depositAmount: ${res.depositAmount || calcularMontoSenia(res.diners) || 10000}})" class="action-button p-2 text-gray-500 hover:text-gray-700 rounded-full hover:bg-gray-100 transition-colors" title="Descargar PDF">
                            <i class='ph ph-download-simple text-lg'></i>
                        </button>
                        ${res.firestoreId && res.firestoreId.length === 20 ? `<button data-firestore-id="${res.firestoreId}" class="action-button edit-res-btn admin-only p-2 text-blue-500 hover:text-blue-700 rounded-full hover:bg-blue-100 transition-colors" title="Editar">
                            <i class="ph ph-pencil-simple text-lg"></i>
                        </button>` : ''}
                        ${res.firestoreId && res.firestoreId.length === 20 ? `<button data-firestore-id="${res.firestoreId}" class="action-button delete-res-btn admin-only p-2 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100 transition-colors" title="Eliminar">
                            <i class="ph ph-trash text-lg"></i>
                        </button>` : ''}
                        ${res.mpPaymentId ? `<button data-id="${res.id}" data-mp-id="${res.mpPaymentId}" class="action-button refresh-payment-btn p-2 text-blue-500 hover:text-blue-700 rounded-full hover:bg-blue-100 transition-colors" title="Actualizar estado de pago">
                            <i class="ph ph-arrow-clockwise text-lg"></i>
                        </button>` : ''}
                        <!-- Comentado temporalmente - Bot√≥n de forzar aprobaci√≥n
                        ${paymentStatus === 'pending' ? `<button data-id="${res.id}" class="action-button force-approve-btn p-2 text-green-500 hover:text-green-700 rounded-full hover:bg-green-100 transition-colors" title="Forzar aprobaci√≥n">
                            <i class="ph ph-check-circle text-lg"></i>
                        </button>` : ''}
                        -->
                    </div>
                    <!-- Botones de Asistencia -->
                    <div class="mt-2 pt-2 border-t border-gray-200">
                        <div class="text-xs text-gray-600 mb-1 text-center">Asistencia</div>
                        <div class="flex items-center justify-center gap-1 flex-wrap">
                            ${generateAttendanceButtons(res)}
                        </div>
                    </div>
                </td>
            `;
        });
    }
    
    // Actualizar totales - usar las reservas sin filtrar para los totales reales
    const totalReservations = allReservations.length > 0 ? allReservations : reservations;
    
    // Actualizar solo los n√∫meros, manteniendo los t√≠tulos
    const totalPeriodElement = getEl('totalDinersPeriod');
    const totalLunchElement = getEl('totalDinersLunch');
    const totalDinnerElement = getEl('totalDinersDinner');
    
    if (totalPeriodElement) {
        const titleElement = totalPeriodElement.querySelector('h3');
        const numberElement = totalPeriodElement.querySelector('p');
        if (numberElement) {
            numberElement.textContent = dinersDay;
        }
    }
    
    if (totalLunchElement) {
        const titleElement = totalLunchElement.querySelector('h3');
        const numberElement = totalLunchElement.querySelector('p');
        if (numberElement) {
            numberElement.textContent = dinersLunch;
        }
    }
    
    if (totalDinnerElement) {
        const titleElement = totalDinnerElement.querySelector('h3');
        const numberElement = totalDinnerElement.querySelector('p');
        if (numberElement) {
            numberElement.textContent = dinersDinner;
        }
    }

    // Actualizar indicadores r√°pidos
    const totalReservas = reservations.length;
    const totalConfirmadas = reservations.filter(r => r.paymentStatus === 'approved' || r.paymentStatus === 'confirmed' || r.paymentStatus === 'pagado-manual').length;
    const totalPendientes = reservations.filter(r => r.paymentStatus === 'pending').length;
    const totalManuales = reservations.filter(r => r.paymentStatus === 'manual').length;
    const totalComensales = dinersDay;

    getEl('totalReservas').textContent = totalReservas;
    getEl('totalConfirmadas').textContent = totalConfirmadas;
    getEl('totalPendientes').textContent = totalPendientes;
    getEl('totalManuales').textContent = totalManuales;
    getEl('totalComensales').textContent = totalComensales;

    // Guardar para exportar
    window._adminReservationsFiltered = reservations;
}

// ========== EXPORTAR A EXCEL ==========
function exportToExcel() {
    // Usar las reservas filtradas seg√∫n el filtro actual
    const reservationsToExport = getFilteredReservationsForExport();
    
    if (!reservationsToExport || reservationsToExport.length === 0) {
        alert('No hay reservas para exportar');
        return;
    }
    
    const data = reservationsToExport.map(res => ({
        'Nombre': res.name || 'Sin nombre',
        'Tel√©fono': res.phone || 'Sin tel√©fono',
        'Fecha': res.date || 'Sin fecha',
        'Hora': res.time || '00:00',
        'Comensales': res.diners || 0,
        'Turno': res.turn || 'no especificado',
        'Estado de Pago': res.paymentStatus || 'no especificado',
        'Creado por': res.createdBy || 'Sistema',
        'Monto de Se√±a': res.depositAmount || 0,
        'M√©todo de Pago': res.paymentMethod || 'No especificado',
        '√Årea': res.area || 'No especificada',
        'Notas': res.notes || 'Sin notas'
    }));
    
    const ws = XLSX.utils.json_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Reservas");
    
    // Crear nombre de archivo con filtro
    let filterSuffix = '';
    switch (currentFilter) {
        case 'almuerzo':
            filterSuffix = '_almuerzos';
            break;
        case 'cena':
            filterSuffix = '_cenas';
            break;
        default:
            filterSuffix = '_todas';
    }
    
    const fileName = `reservas_${new Date().toISOString().split('T')[0]}${filterSuffix}.xlsx`;
    XLSX.writeFile(wb, fileName);
}

// ========== ACCIONES SOBRE RESERVAS ==========
async function deleteReservation(reservationId, reservationData = {}) {
    try {
        
        // Verificar que reservationId no sea null
        if (!reservationId) {
            console.error('Error: reservationId es null o undefined');
            alert('Error: No se pudo identificar la reserva a eliminar');
            return;
        }

        // Verificar que la reserva existe antes de eliminar
        const docRef = doc(db, "reservations", reservationId);
        const docSnap = await getDoc(docRef);
        
        if (!docSnap.exists()) {
            // Verificar si est√° en la lista de cancelaciones
            const cancellationsQuery = query(collection(db, "cancellations"), where("reservationId", "==", reservationId));
            const cancellationsSnap = await getDocs(cancellationsQuery);
            
            if (!cancellationsSnap.empty) {
                showSuccessModal('Esta reserva ya fue cancelada anteriormente. Actualizando la vista...');
            } else {
                showSuccessModal('Esta reserva no existe en la base de datos. Actualizando la vista...');
            }
            
            // Actualizar la interfaz para reflejar el estado real
            const dateFilter = getEl('dateFilter');
            const periodSelector = getEl('periodSelector');
            if (dateFilter && dateFilter.value) {
                fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
            }
            return;
        }

        const reservationDoc = docSnap.data();

        // Guardar registro de cancelaci√≥n en Firestore antes de eliminar
        const cancellationData = {
            reservationId: reservationId,
            name: reservationData.name || reservationDoc.name || '',
            phone: reservationData.phone || reservationDoc.phone || '',
            date: reservationData.date || reservationDoc.date || '',
            time: reservationData.time || reservationDoc.time || '',
            diners: reservationData.diners || reservationDoc.diners || '',
            area: reservationData.area || reservationDoc.area || '',
            notes: reservationData.notes || reservationDoc.notes || '',
            cancelledAt: new Date().toISOString(),
            cancelledBy: 'admin',
            motivo: reservationData.motivo || '',
            // Guardar todos los campos extra de la reserva original
            ...reservationDoc
        };
        
        await setDoc(doc(db, "cancellations", reservationId + '_' + Date.now()), cancellationData);
        
        const docId = reservationData.firestoreId || reservationId;
        await deleteDoc(doc(db, 'reservations', docId));
        
        // Enviar notificaci√≥n de cancelaci√≥n
        const notificationData = {
            ...reservationData,
            createdBy: reservationData.createdBy || reservationDoc.createdBy || 'admin'
        };
        await sendCancellationNotification(notificationData);
        
        // Mostrar modal de √©xito
        showSuccessModal('Reserva eliminada correctamente');
        
        // Actualizar la interfaz inmediatamente
        const dateFilter = getEl('dateFilter');
        const periodSelector = getEl('periodSelector');
        if (dateFilter && dateFilter.value) {
            fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
        }
        
    } catch (error) {
        console.error('Error al eliminar reserva:', error);
        alert('Error al eliminar la reserva: ' + error.message);
    }
}

// MODAL VISUAL DE ELIMINACI√ìN (ADMIN, UNIFICADO) con campo de motivo
function showAdminDeleteModalVisual(reservation, onConfirm, onCancel) {
    // Eliminar cualquier modal anterior
    const oldModal = document.getElementById('custom-modal-overlay');
    if (oldModal) oldModal.remove();
    const overlay = document.createElement('div');
    overlay.id = 'custom-modal-overlay';
    overlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50';
    overlay.style.zIndex = 9999;
    const modal = document.createElement('div');
    modal.className = 'bg-white rounded-2xl shadow-2xl p-8 max-w-sm w-full text-center relative border-2 border-red-200';
    // Icono de advertencia
    const icon = document.createElement('div');
    icon.innerHTML = '<div class="flex justify-center mb-2"><span class="inline-flex items-center justify-center w-14 h-14 rounded-full bg-red-100"><svg class="w-10 h-10 text-red-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/></svg></span></div>';
    modal.appendChild(icon);
    // T√≠tulo
    const titleEl = document.createElement('h2');
    titleEl.className = 'text-2xl font-bold mb-2 text-red-700';
    titleEl.textContent = '¬øEliminar Reserva?';
    modal.appendChild(titleEl);
    // Mensaje
    const msgEl = document.createElement('p');
    msgEl.className = 'mb-4 text-gray-700';
    msgEl.textContent = '¬øEst√°s seguro de que quieres eliminar esta reserva? Esta acci√≥n no se puede deshacer.';
    modal.appendChild(msgEl);
    // Campo de motivo
    const motivoLabel = document.createElement('label');
    motivoLabel.className = 'block text-sm font-medium text-gray-700 mb-1 text-left';
    motivoLabel.textContent = 'Motivo de la cancelaci√≥n (opcional):';
    modal.appendChild(motivoLabel);
    const motivoInput = document.createElement('textarea');
    motivoInput.className = 'w-full p-2 border border-gray-300 rounded mb-4';
    motivoInput.placeholder = 'Ej: Cliente avis√≥, error en la reserva, etc.';
    modal.appendChild(motivoInput);
    // Botones
    const btnGroup = document.createElement('div');
    btnGroup.className = 'flex flex-col gap-2 mt-2';
    const confirmBtn = document.createElement('button');
    confirmBtn.className = 'w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-700 transition text-lg';
    confirmBtn.textContent = 'Eliminar';
    btnGroup.appendChild(confirmBtn);
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'w-full bg-gray-200 text-gray-800 font-bold py-3 px-4 rounded-lg hover:bg-gray-300 transition text-lg';
    cancelBtn.textContent = 'Cancelar';
    btnGroup.appendChild(cancelBtn);
    modal.appendChild(btnGroup);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    confirmBtn.onclick = () => {
        if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
        }
        // Pasar el motivo al callback
        if (typeof onConfirm === 'function') {
            if (reservation) {
            reservation.motivo = motivoInput.value;
            onConfirm(reservation);
            } else {
                // Si reservation es null, crear un objeto b√°sico con el motivo
                const reservationWithMotivo = {
                    id: null,
                    motivo: motivoInput.value
                };
                onConfirm(reservationWithMotivo);
            }
        }
    };
    cancelBtn.onclick = () => {
        if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
        }
        if (onCancel) onCancel();
    };
}

async function refreshPaymentStatus(reservationId, mpPaymentId) {
    try {
        const response = await fetch(`https://api.mercadopago.com/v1/payments/${mpPaymentId}`, {
            headers: {
                'Authorization': `Bearer ${import.meta.env.VITE_MERCADOPAGO_ACCESS_TOKEN}`
            }
        });
        const paymentData = await response.json();
        
        if (paymentData.status) {
            await updateDoc(doc(db, "reservations", reservationId), {
                paymentStatus: paymentData.status,
                status: paymentData.status,
                lastPaymentCheck: new Date().toISOString()
            });
            alert('Estado de pago actualizado exitosamente');
            const dateFilter = getEl('dateFilter');
            const periodSelector = getEl('periodSelector');
            if (dateFilter && dateFilter.value) {
                fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
            }
        } else {
            alert('No se pudo obtener el estado del pago');
        }
    } catch (error) {
        console.error('Error al actualizar estado de pago:', error);
        alert('Error al actualizar el estado de pago');
    }
}

async function forcePaymentStatusUpdate(reservationId, paymentId = null) {
    try {
        // Verificar que el documento existe antes de actualizarlo
        const docRef = doc(db, "reservations", reservationId);
        const docSnap = await getDoc(docRef);
        
        if (!docSnap.exists()) {
            // Verificar si est√° en la lista de cancelaciones
            const cancellationsQuery = query(collection(db, "cancellations"), where("reservationId", "==", reservationId));
            const cancellationsSnap = await getDocs(cancellationsQuery);
            
            if (!cancellationsSnap.empty) {
                alert('Esta reserva ya fue cancelada anteriormente. No se puede actualizar su estado.');
            } else {
                alert('Esta reserva no existe en la base de datos. Actualizando la vista...');
            }
            
            // Actualizar la interfaz para reflejar el estado real
            const dateFilter = getEl('dateFilter');
            const periodSelector = getEl('periodSelector');
            if (dateFilter && dateFilter.value) {
                fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
            }
            return false;
        }
        
        // Si el documento existe, actualizarlo
        await updateDoc(docRef, {
            paymentStatus: 'approved',
            status: 'approved',
            lastPaymentCheck: new Date().toISOString()
        });
        return true;
    } catch (error) {
        console.error('Error al forzar actualizaci√≥n de estado:', error);
        return false;
    }
}

// ========== GENERAR COMPROBANTE PDF ==========
function generarComprobantePDF({ nombre, fecha, monto, reservaId, paymentStatus, estado, status, paymentId, mpPaymentId, diners, time, turn, area, notes, depositAmount, phone }) {
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        function generatePDFContent(logoDataUrl = null) {
            if (logoDataUrl) {
                doc.addImage(logoDataUrl, 'PNG', 20, 15, 25, 25);
            }
            const logoX = 20;
            const logoY = 15;
            const logoW = 25;
            const textX = logoX + logoW + 10;
            const titleY = logoY + 10;
            const subtitleY = logoY + 20;
            doc.setFontSize(20);
            doc.setTextColor(20, 83, 45);
            doc.text('Parrilla Los Nogales', textX, titleY, { align: 'left' });
            doc.setFontSize(16);
            doc.setTextColor(34, 197, 94);
            doc.text('Comprobante de Reserva', textX, subtitleY, { align: 'left' });
            doc.setDrawColor(34, 197, 94);
            doc.setLineWidth(0.5);
            doc.line(20, 45, 190, 45);
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.setFont('helvetica', 'bold');
            doc.text('Datos del Cliente:', 20, 60);
            doc.setFont('helvetica', 'normal');
            doc.text(`Nombre: ${nombre || 'No especificado'}`, 20, 70);
            doc.text(`Tel√©fono: ${phone || ''}`, 20, 76);
            doc.text(`√Årea: ${area || 'No especificada'}`, 20, 82);
            doc.text(`Fecha de Reserva: ${fecha || 'No especificada'}`, 20, 88);
            doc.text(`Hora: ${time || 'No especificada'}`, 20, 94);
            doc.text(`Turno: ${turn || 'No especificado'}`, 20, 100);
            doc.text(`Comensales: ${diners || 'No especificado'}`, 20, 106);
            doc.setFont('helvetica', 'bold');
            doc.text('Detalles del Pago:', 20, 120);
            doc.setFont('helvetica', 'normal');
            let montoSenia = monto;
            if (typeof montoSenia === 'undefined' || montoSenia === null) {
                if (typeof depositAmount !== 'undefined') montoSenia = depositAmount;
                else if (typeof diners !== 'undefined') montoSenia = calcularMontoSenia(diners);
                else montoSenia = 10;
            }
            doc.text(`Monto de Se√±a: $${(montoSenia).toLocaleString('es-AR')}`, 20, 126);
            let estadoPago = 'PENDIENTE';
            if (typeof paymentStatus !== 'undefined' && paymentStatus) {
                if (paymentStatus === 'approved' || paymentStatus === 'confirmed' || paymentStatus === 'PAGADO') {
                    estadoPago = 'PAGADO';
                } else if (paymentStatus === 'pending' || paymentStatus === 'PENDIENTE') {
                    estadoPago = 'PENDIENTE';
                } else if (paymentStatus === 'rejected' || paymentStatus === 'RECHAZADO') {
                    estadoPago = 'RECHAZADO';
                } else {
                    estadoPago = paymentStatus.toUpperCase();
                }
            } else if (typeof estado !== 'undefined' && estado) {
                estadoPago = estado.toUpperCase();
            } else if (typeof status !== 'undefined' && status) {
                estadoPago = status.toUpperCase();
            }
            doc.text(`Estado: ${estadoPago}`, 20, 132);
            
            // Mejorar la l√≥gica para mostrar el ID de pago
            let paymentIdToShow = '';
            if (paymentId && paymentId !== '' && paymentId !== 'undefined') {
                paymentIdToShow = paymentId;
            } else if (typeof mpPaymentId !== 'undefined' && mpPaymentId && mpPaymentId !== '' && mpPaymentId !== 'undefined') {
                paymentIdToShow = mpPaymentId;
            }
            
            if (paymentIdToShow) {
                doc.text(`ID de Pago: ${paymentIdToShow}`, 20, 138);
                console.log('üìÑ [PDF] ID de pago incluido en PDF:', paymentIdToShow);
            } else {
                console.log('‚ö†Ô∏è [PDF] No se encontr√≥ ID de pago para incluir en PDF');
            }
            doc.setFont('helvetica', 'bold');
            doc.text('Informaci√≥n T√©cnica:', 20, 152);
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            doc.text(`ID de Reserva: ${reservaId || 'No disponible'}`, 20, 160);
            doc.text(`Fecha de Emisi√≥n: ${new Date().toLocaleDateString('es-AR')}`, 20, 166);
            doc.text(`Hora de Emisi√≥n: ${new Date().toLocaleTimeString('es-AR', { hour: '2-digit', minute: '2-digit', hour12: false })}`, 20, 172);
            if (notes && notes !== '') {
                doc.setFont('helvetica', 'bold');
                doc.text('Notas:', 20, 182);
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(10);
                doc.text(notes, 20, 188);
            }
            doc.setFontSize(10);
            doc.setTextColor(107, 114, 128);
            doc.text('Notas importantes:', 20, 200);
            doc.setFontSize(8);
            doc.text('‚Ä¢ Este es un comprobante generado autom√°ticamente', 20, 207);
            doc.text('‚Ä¢ La reserva tiene una tolerancia de 15 minutos', 20, 214);
            doc.text('‚Ä¢ En caso de cancelaci√≥n, avisar con 24h de anticipaci√≥n', 20, 221);
            doc.text('‚Ä¢ El resto del monto se abona al finalizar la comida', 20, 228);
            doc.setFontSize(8);
            doc.setTextColor(156, 163, 175);
            doc.text('Parrilla Los Nogales - Sistema de Reservas Automatizado', 105, 280, { align: 'center' });
            const fileName = `comprobante_reserva_${reservaId || 'nogales'}_${new Date().toISOString().split('T')[0]}.pdf`;
            doc.save(fileName);
        }
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                const logoDataUrl = canvas.toDataURL('image/png');
                generatePDFContent(logoDataUrl);
            } catch (logoError) {
                console.warn('‚ö†Ô∏è [PDF_GENERATE] Error al procesar logo:', logoError);
                generatePDFContent();
            }
        };
        img.onerror = function() {
            console.warn('‚ö†Ô∏è [PDF_GENERATE] No se pudo cargar el logo, continuando sin √©l');
            generatePDFContent();
        };
        img.src = './Logo/Logo-Los-Nogales.png';
    } catch (error) {
        console.error('‚ùå [PDF_GENERATE] Error al generar PDF:', error);
        alert('Error al generar el comprobante PDF. Por favor, intenta de nuevo.');
    }
}

// ========== B√öSQUEDA AVANZADA ==========
function setupAdminAdvancedSearch() {
    const showSearchButton = getEl('show-search-button');
    const searchModal = getEl('search-modal');
    if (showSearchButton && searchModal) {
        showSearchButton.onclick = () => {
            searchModal.innerHTML = `
                <div class="relative top-10 md:top-20 mx-auto p-5 border w-full max-w-lg shadow-lg rounded-md bg-white">
                    <div class="mt-3">
                        <h3 class="text-lg text-center leading-6 font-medium text-gray-900">Buscar Reserva</h3>
                        <form id="search-form" class="mt-4 px-7 py-3 space-y-3">
                            <label for="search-phone" class="block text-sm font-medium text-gray-700">B√∫squeda avanzada</label>
                            <div class="flex gap-2">
                                <input type="text" id="search-phone" placeholder="Nombre, tel√©fono, fecha, √°rea, notas, ID..." required class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-green-500">
                                <button type="submit" class="bg-green-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-800">Buscar</button>
                            </div>
                            <p class="text-xs text-gray-500">Puedes buscar por: nombre, tel√©fono, fecha (YYYY-MM-DD), √°rea, notas, ID de reserva</p>
                        </form>
                        <div id="search-results-container" class="mt-4 px-1 md:px-7 space-y-3 max-h-60 overflow-y-auto"></div>
                        <div id="search-message" class="text-center p-4"></div>
                        <div class="items-center px-4 py-3 mt-4 border-t">
                            <button id="close-search-modal-button" class="px-4 py-2 bg-gray-200 text-gray-800 text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-300">Cerrar</button>
                        </div>
                    </div>
                </div>
            `;
            searchModal.classList.remove('hidden');
            const closeBtn = getEl('close-search-modal-button');
            if (closeBtn) closeBtn.onclick = () => searchModal.classList.add('hidden');
            const searchForm = getEl('search-form');
            if (searchForm) {
                searchForm.onsubmit = async (e) => {
                    e.preventDefault();
                    const searchTerm = getEl('search-phone').value.trim().toLowerCase();
                    const resultsContainer = getEl('search-results-container');
                    const messageEl = getEl('search-message');
                    resultsContainer.innerHTML = '';
                    messageEl.textContent = 'Buscando...';
                    if (!searchTerm) {
                        messageEl.textContent = 'Por favor, ingresa un nombre o n√∫mero de tel√©fono.';
                        return;
                    }
                    
                    try {
                        // Usar la funci√≥n mejorada de b√∫squeda
                        const matchedReservations = await searchClientReservations(searchTerm, true); // true = isAdmin
                        
                        if (matchedReservations.length === 0) {
                            messageEl.textContent = 'No se encontraron reservas con los datos ingresados.';
                            return;
                        }
                        
                        // Ordenar por fecha (m√°s recientes primero) y mostrar resultados
                        const sortedReservations = matchedReservations.sort((a, b) => {
                            const dateA = new Date(`${a.date}T${a.time || '00:00'}`);
                            const dateB = new Date(`${b.date}T${b.time || '00:00'}`);
                            return dateB - dateA; // M√°s recientes primero
                        });
                        
                        messageEl.textContent = `Se encontraron ${sortedReservations.length} reserva(s):`;
                        
                        sortedReservations.forEach(res => {
                            const dateFormatted = new Date(res.date + 'T00:00:00').toLocaleDateString('es-AR');
                            let paymentStatusClass = '';
                            let paymentStatusText = '';
                            if (res.paymentStatus === 'approved' || res.paymentStatus === 'confirmed') {
                                paymentStatusClass = 'bg-green-100 text-green-800';
                                paymentStatusText = 'Pagada';
                            } else if (res.paymentStatus === 'pending') {
                                paymentStatusClass = 'bg-yellow-100 text-yellow-800';
                                paymentStatusText = 'Pendiente';
                            } else if (res.paymentStatus === 'rejected') {
                                paymentStatusClass = 'bg-red-100 text-red-800';
                                paymentStatusText = 'Rechazada';
                            } else {
                                paymentStatusClass = 'bg-gray-100 text-gray-700';
                                paymentStatusText = 'Desconocido';
                            }
                            
                            const resultCard = document.createElement('div');
                            resultCard.className = `p-3 border rounded-lg bg-gray-50 flex justify-between items-center`;
                            resultCard.setAttribute('data-id', res.firestoreId || res.id);
                            resultCard.innerHTML = `
                                <div>
                                    <p class="font-bold">${res.name || 'Sin nombre'}</p>
                                    <p class="text-sm text-gray-600">${dateFormatted} - ${res.time || '00:00'} hs - ${res.diners || 0} personas</p>
                                    <p class="text-xs mt-1">
                                        <span class="px-2 py-1 font-semibold leading-tight rounded-full ${paymentStatusClass}">${paymentStatusText}</span>
                                        ${res.area ? `<span class="ml-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-xs">${res.area}</span>` : ''}
                                    </p>
                                </div>
                                <div class="flex gap-2">
                                    ${res.firestoreId && res.firestoreId.length === 20 ? `<button data-firestore-id="${res.firestoreId}" class="action-button edit-res-btn admin-only p-2 text-blue-500 hover:text-blue-700 rounded-full hover:bg-blue-100 transition-colors" title="Editar">
                                        <i class="ph ph-pencil-simple text-lg"></i>
                                    </button>` : ''}
                                    ${res.firestoreId && res.firestoreId.length === 20 ? `<button data-firestore-id="${res.firestoreId}" class="action-button delete-res-btn admin-only p-2 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100 transition-colors" title="Eliminar">
                                        <i class="ph ph-trash text-lg"></i>
                                    </button>` : ''}
                                </div>
                            `;
                            resultsContainer.appendChild(resultCard);
                        });
                        
                    } catch (error) {
                        console.error('Error en b√∫squeda:', error);
                        messageEl.textContent = 'Error al buscar reservas. Intenta de nuevo.';
                    }
                };
            }
            // Listener para acciones en resultados
            searchModal.addEventListener('click', async (e) => {
                const button = e.target.closest('.action-button');
                if (!button) return;
                const id = button.dataset.id;
                if (button.classList.contains('edit-res-btn')) {
                    // Solo abrir modal si el id es de 20 caracteres (firestoreId v√°lido)
                    if (id && id.length === 20) {
                        await openEditModal(id);
                        // Actualizar resultados de b√∫squeda despu√©s de editar
                        setTimeout(() => {
                            const searchForm = getEl('search-form');
                            if (searchForm) {
                                searchForm.requestSubmit();
                            }
                        }, 1500); // Esperar a que se cierre el modal de edici√≥n
                    }
                    // Si no, no hacer nada
                } else if (button.classList.contains('delete-res-btn')) {
                    // Usar siempre firestoreId si existe
                    const firestoreId = button.dataset.firestoreId;
                    const reservationId = firestoreId && firestoreId.length === 20 ? firestoreId : button.dataset.id;
                    if (reservationId) {
                        // Buscar los datos de la reserva para mostrar en el modal de confirmaci√≥n
                        const reservationRow = button.closest('tr');
                        let reservationData = { id: reservationId };
                        if (reservationRow) {
                          const nameCell = reservationRow.querySelector('td:nth-child(1)');
                          const dateCell = reservationRow.querySelector('td:nth-child(3)');
                          const timeCell = reservationRow.querySelector('td:nth-child(4)');
                          const dinersCell = reservationRow.querySelector('td:nth-child(5)');
                          if (nameCell) reservationData.name = nameCell.textContent?.trim();
                          if (dateCell) reservationData.date = dateCell.textContent?.trim();
                          if (timeCell) reservationData.time = timeCell.textContent?.trim();
                          if (dinersCell) reservationData.diners = dinersCell.textContent?.trim();
                        }
                        showAdminDeleteModalVisual(reservationData, async (reservation) => {
                          try {
                            await deleteReservation(reservation.id, reservation);
                            // Actualizar resultados de b√∫squeda despu√©s de eliminar
                            setTimeout(() => {
                                const searchForm = getEl('search-form');
                                if (searchForm) {
                                    searchForm.requestSubmit();
                                }
                            }, 1000); // Esperar a que se cierre el modal de eliminaci√≥n
                          } catch (error) {
                            alert('Error al eliminar la reserva.');
                          }
                        });
                    }
                }
            });
        };
    }
}

/**
 * Busca reservas por nombre, tel√©fono, fecha, √°rea, notas, ID, etc.
 * El admin puede ver todas las reservas (pasadas, actuales y futuras).
 */
async function searchClientReservations(searchTerm, isAdmin = true) {
    try {
        // Obtener todas las reservas
        const reservationsRef = collection(db, "reservations");
        const snapshot = await getDocs(reservationsRef);
        const allReservations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        const today = getLocalDateString();
        const search = searchTerm.trim().toLowerCase();
        const matchedReservations = allReservations.filter(res => {
            // Si es admin, no filtrar por fecha (puede ver todas las reservas)
            // B√∫squeda por m√∫ltiples campos
            const nameMatch = res.name && res.name.toLowerCase().includes(search);
            const phoneMatch = res.phone && res.phone.includes(search);
            const dateMatch = res.date && res.date.includes(search);
            const areaMatch = res.area && res.area.toLowerCase().includes(search);
            const notesMatch = res.notes && res.notes.toLowerCase().includes(search);
            const idMatch = res.id && res.id.toLowerCase().includes(search);
            const firestoreIdMatch = res.firestoreId && res.firestoreId.toLowerCase().includes(search);
            return nameMatch || phoneMatch || dateMatch || areaMatch || notesMatch || idMatch || firestoreIdMatch;
        });
        // Verificar en tiempo real que cada reserva siga existiendo en Firestore
        const validReservations = [];
        for (const res of matchedReservations) {
            try {
                const docId = res.firestoreId || res.id;
                if (docId) {
                    const docSnap = await getDoc(doc(db, 'reservations', docId));
                    if (docSnap.exists()) {
                        validReservations.push(res);
                    }
                } else {
                    const docSnap = await getDoc(doc(db, 'reservations', res.id));
                    if (docSnap.exists()) {
                        validReservations.push(res);
                    }
                }
            } catch (error) {
                validReservations.push(res);
            }
        }
        return validReservations;
    } catch (error) {
        console.error("‚ùå [ADMIN_SEARCH] Error buscando reservas:", error);
        return [];
    }
}

// ========== NOTIFICACIONES PUSH PARA ADMIN ==========
let swRegistration = null;

/**
 * Registra el Service Worker para notificaciones push del admin
 */
async function registerAdminServiceWorker() {
    if ('serviceWorker' in navigator && 'PushManager' in window) {
        try {
            swRegistration = await navigator.serviceWorker.register('/firebase-messaging-sw.js', { scope: '/' });
            // Solicitar permisos de notificaci√≥n autom√°ticamente
            if ('Notification' in window) {
                await Notification.requestPermission();
            }
            return swRegistration;
        } catch (error) {
            console.error('‚ùå [ADMIN_PUSH] Error registrando Service Worker:', error);
        }
    }
    return null;
}

/**
 * Solicita permisos para notificaciones del admin
 */
async function requestAdminNotificationPermission() {
    if ('Notification' in window) {
        const permission = await Notification.requestPermission();
        console.log('üîî [ADMIN_PUSH] Permiso de notificaci√≥n admin:', permission);
        
        // Actualizar el bot√≥n seg√∫n el estado del permiso
        updateNotificationButton(permission);
        
        return permission === 'granted';
    }
    return false;
}

/**
 * Actualiza el estado del bot√≥n de notificaciones
 */
function updateNotificationButton(permission) {
    const button = getEl('enable-notifications-btn');
    const statusSpan = getEl('notification-status');
    
    if (!button || !statusSpan) return;
    
    switch (permission) {
        case 'granted':
            button.className = 'bg-green-600 text-white px-4 py-2 rounded-lg transition flex items-center gap-2';
            statusSpan.innerHTML = '<i class="ph ph-check-circle text-lg"></i> Notificaciones Activas';
            button.disabled = true;
            break;
        case 'denied':
            button.className = 'bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition flex items-center gap-2';
            statusSpan.innerHTML = '<i class="ph ph-x-circle text-lg"></i> Notificaciones Bloqueadas';
            break;
        case 'default':
            button.className = 'bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition flex items-center gap-2';
            statusSpan.innerHTML = '<i class="ph ph-bell text-lg"></i> Activar Notificaciones';
            break;
    }
}

/**
 * Maneja el clic en el bot√≥n de notificaciones
 */
async function handleNotificationButtonClick() {
    const button = getEl('enable-notifications-btn');
    if (!button) return;
    
    button.disabled = true;
    button.innerHTML = '<i class="ph ph-circle-notch text-lg animate-spin"></i> Solicitando...';
    
    try {
        const permission = await requestAdminNotificationPermission();
        
        if (permission) {
            console.log('‚úÖ [ADMIN_PUSH] Permisos de notificaci√≥n concedidos');
            // Enviar notificaci√≥n de prueba
            await sendTestNotification();
        } else {
            console.log('‚ùå [ADMIN_PUSH] Permisos de notificaci√≥n denegados');
            alert('Para recibir notificaciones de nuevas reservas, por favor permite las notificaciones en tu navegador.');
        }
    } catch (error) {
        console.error('‚ùå [ADMIN_PUSH] Error solicitando permisos:', error);
        alert('Error al activar las notificaciones. Por favor, intenta de nuevo.');
    } finally {
        // El bot√≥n se actualiza en updateNotificationButton
    }
}

/**
 * Env√≠a una notificaci√≥n de prueba optimizada para m√≥vil (Samsung Galaxy S23)
 */
async function sendTestNotification() {
    if ('Notification' in window && Notification.permission === 'granted') {
        try {
            const notification = new Notification('üß™ Prueba M√≥vil', {
                body: '‚úÖ Notificaciones funcionando en tu Samsung Galaxy S23\nüì± Recibir√°s alertas de reservas, pagos y recordatorios',
                icon: '/Logo/Logo-Los-Nogales.png',
                badge: '/Logo/favicon-32x32.png',
                tag: 'admin-test-mobile',
                requireInteraction: true,
                vibrate: [200, 100, 200, 100, 200],
                silent: false, // Sonido activado para m√≥vil
                data: {
                    type: 'admin_test_mobile',
                    timestamp: Date.now().toString(),
                    source: 'admin_mobile',
                    priority: 'high'
                }
            });
            
            notification.onclick = function() {
                window.focus();
                notification.close();
                console.log('üì± [ADMIN_MOBILE] Notificaci√≥n de prueba clickeada en m√≥vil');
            };
            
            console.log('‚úÖ [ADMIN_MOBILE] Notificaci√≥n de prueba m√≥vil enviada');
            return notification;
        } catch (error) {
            console.error('‚ùå [ADMIN_MOBILE] Error enviando notificaci√≥n de prueba:', error);
        }
    } else {
        console.warn('‚ö†Ô∏è [ADMIN_MOBILE] Permisos de notificaci√≥n no concedidos');
    }
}

// ========== SISTEMA DE RECORDATORIOS AUTOM√ÅTICOS ==========

/**
 * Sistema autom√°tico de recordatorios para el administrador
 */
function setupAdminReminderSystem() {
    // Verificar recordatorios cada 30 minutos
    setInterval(async () => {
        if ('Notification' in window && Notification.permission === 'granted') {
            try {
                const today = getLocalDateString();
                const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                
                // Buscar reservas para ma√±ana (recordatorio 24h)
                const reservationsQuery = query(
                    collection(db, "reservations"),
                    where("date", "==", tomorrow),
                    where("paymentStatus", "in", ["approved", "confirmed"])
                );
                
                const snapshot = await getDocs(reservationsQuery);
                snapshot.forEach(doc => {
                    const reservation = { id: doc.id, ...doc.data() };
                    sendReminderNotification(reservation, 24);
                });
                
                // Buscar reservas para hoy en las pr√≥ximas 2 horas
                const now = new Date();
                const twoHoursFromNow = new Date(now.getTime() + 2 * 60 * 60 * 1000);
                
                const todayReservationsQuery = query(
                    collection(db, "reservations"),
                    where("date", "==", today),
                    where("paymentStatus", "in", ["approved", "confirmed"])
                );
                
                const todaySnapshot = await getDocs(todayReservationsQuery);
                todaySnapshot.forEach(doc => {
                    const reservation = { id: doc.id, ...doc.data() };
                    const reservationTime = new Date(`${today}T${reservation.time}:00`);
                    
                    if (reservationTime > now && reservationTime <= twoHoursFromNow) {
                        sendReminderNotification(reservation, 2);
                    }
                });
                
                console.log('‚úÖ [ADMIN_MOBILE] Sistema de recordatorios ejecutado');
            } catch (error) {
                console.error('‚ùå [ADMIN_MOBILE] Error en sistema de recordatorios:', error);
            }
        }
    }, 30 * 60 * 1000); // 30 minutos
    
    console.log('‚úÖ [ADMIN_MOBILE] Sistema de recordatorios autom√°ticos configurado');
}

/**
 * Sistema de detecci√≥n de notificaciones del cliente - MEJORADO
 */
function setupAdminNotificationListener() {
    // Escuchar eventos de reserva pendiente de pago
    window.addEventListener('pendingPayment', (event) => {
        console.log('üìß [ADMIN_LISTEN] Reserva pendiente de pago detectada:', event.detail);
        sendNewReservationNotification({
            ...event.detail.data,
            notificationType: 'pending'
        });
    });
    // Escuchar eventos de pago confirmado
    window.addEventListener('paymentConfirmed', (event) => {
        console.log('üìß [ADMIN_LISTEN] Pago confirmado detectado:', event.detail);
        sendPaymentConfirmedNotification({
            ...event.detail.data,
            notificationType: 'paid'
        });
    });
    // Compatibilidad: seguir escuchando el evento antiguo solo para reservas ya pagadas
    window.addEventListener('newReservation', (event) => {
        if (event.detail && event.detail.data && event.detail.data.paymentStatus === 'approved') {
            sendNewReservationNotification({
                ...event.detail.data,
                notificationType: 'paid'
            });
        }
    });
    // Verificar localStorage peri√≥dicamente para notificaciones
    setInterval(() => {
        try {
            const notificationData = localStorage.getItem('adminNotification');
            if (notificationData) {
                const notification = JSON.parse(notificationData);
                const timeDiff = Date.now() - notification.timestamp;
                // Solo procesar notificaciones recientes (√∫ltimos 5 segundos)
                if (timeDiff < 5000) {
                    if (notification.type === 'PENDING_PAYMENT') {
                        sendNewReservationNotification({
                            ...notification.data,
                            notificationType: 'pending'
                        });
                    } else if (notification.type === 'PAYMENT_CONFIRMED') {
                        sendPaymentConfirmedNotification({
                            ...notification.data,
                            notificationType: 'paid'
                        });
                    } else if (notification.type === 'NEW_RESERVATION' && notification.data && notification.data.paymentStatus === 'approved') {
                        sendNewReservationNotification({
                            ...notification.data,
                            notificationType: 'paid'
                        });
                    }
                    // Limpiar la notificaci√≥n procesada
                    localStorage.removeItem('adminNotification');
                }
            }
        } catch (error) {
            console.error('‚ùå [ADMIN_LISTEN] Error procesando notificaci√≥n:', error);
        }
    }, 2000); // Verificar cada 2 segundos
    console.log('‚úÖ [ADMIN_LISTEN] Listener de notificaciones mejorado configurado');
}

/**
 * Configura el bot√≥n de notificaciones y verifica el estado inicial
 */
function setupNotificationButton() {
    const button = getEl('enable-notifications-btn');
    if (!button) return;
    
    // Verificar estado inicial de las notificaciones
    if ('Notification' in window) {
        updateNotificationButton(Notification.permission);
    }
    
    // Agregar evento de clic
    button.addEventListener('click', handleNotificationButtonClick);
    
    console.log('‚úÖ [ADMIN] Bot√≥n de notificaciones configurado');
}

// L√≥gica de login de administrador
// Variables globales para el rol del usuario
let currentUserRole = null; // 'admin' | 'observer' | null
let isAuthenticated = false;
let sessionTimeout = null;

function setupAdminLogin() {
    const loginModal = document.getElementById('admin-login-modal');
    const loginForm = document.getElementById('admin-login-form');
    const loginError = document.getElementById('admin-login-error');
    const adminPanel = document.getElementById('admin-panel-container');
    const exitAdminButton = document.getElementById('exit-admin-button');

    if (!loginForm) return;

    loginForm.addEventListener('submit', function(e) {
        e.preventDefault();
        const inputPassword = document.getElementById('admin-password').value;
        const ADMIN_PASSWORD = import.meta.env.VITE_ADMIN_PASSWORD;
        const OBSERVER_PASSWORD = import.meta.env.VITE_OBSERVER_PASSWORD; // Contrase√±a para observador
        
        if (inputPassword === ADMIN_PASSWORD) {
            // Acceso completo como administrador - SESI√ìN PERSISTENTE
            currentUserRole = 'admin';
            isAuthenticated = true;
            loginModal.classList.add('hidden');
            loginModal.classList.remove('flex');
            if (adminPanel) adminPanel.style.display = 'block';
            loginError.textContent = '';
            
            // Mostrar indicador de rol
            showRoleIndicator('Administrador', 'green');
            
            // Habilitar todas las funcionalidades
            enableAllFeatures();
            
            // Cambiar el bot√≥n a "Salir del panel"
            updateExitButtonState(true);
            
            // Configurar sesi√≥n persistente (sin auto-cierre)
            setupPersistentSession();
            
            // Inicializar sistema de asistencias despu√©s de establecer rol
            setTimeout(() => {
                initializeAttendanceSystem();
            }, 100);
            
        } else if (inputPassword === OBSERVER_PASSWORD) {
            // Acceso limitado como observador - SESI√ìN PERSISTENTE
            currentUserRole = 'observer';
            isAuthenticated = true;
            loginModal.classList.add('hidden');
            loginModal.classList.remove('flex');
            if (adminPanel) adminPanel.style.display = 'block';
            loginError.textContent = '';
            
            // Mostrar indicador de rol
            showRoleIndicator('Observador', 'blue');
            
            // Habilitar solo funcionalidades de observador
            enableObserverFeatures();
            
            // Cambiar el bot√≥n a "Salir del panel"
            updateExitButtonState(true);
            
            // Configurar sesi√≥n persistente (hasta cerrar manualmente)
            setupPersistentSession();
            
            // Inicializar sistema de asistencias despu√©s de establecer rol
            setTimeout(() => {
                initializeAttendanceSystem();
            }, 100);
            
        } else {
            loginError.textContent = 'Contrase√±a incorrecta.';
        }
    });

    if (exitAdminButton) {
        exitAdminButton.addEventListener('click', () => {
            if (isAuthenticated) {
                // Si est√° autenticado, salir del panel
                logoutUser();
            } else {
                // Si no est√° autenticado, mostrar el modal de login
                loginModal.classList.remove('hidden');
                loginModal.classList.add('flex');
            }
        });
    }

    // Mostrar SIEMPRE el modal de login al cargar la p√°gina
    window.addEventListener('DOMContentLoaded', () => {
        logoutUser(''); // Inicializar estado sin mensaje
        
        // Inicializar el bot√≥n en estado "Entrar al panel"
        updateExitButtonState(false);
    });
}

// Funci√≥n para mostrar indicador de rol
function showRoleIndicator(role, color) {
    let indicator = document.getElementById('role-indicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'role-indicator';
        indicator.className = `px-3 py-1 rounded-full text-white text-sm font-medium shadow-lg`;
        
        // Insertar en la barra superior junto al bot√≥n de salir
        const headerContainer = document.querySelector('.mb-8.flex.flex-col.sm\\:flex-row.items-center.justify-between.gap-4');
        if (headerContainer) {
            // Crear un contenedor para el bot√≥n y el indicador
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'flex items-center gap-3';
            
            // Mover el bot√≥n de salir al contenedor
            const exitButton = document.getElementById('exit-admin-button');
            if (exitButton) {
                exitButton.remove();
                buttonContainer.appendChild(exitButton);
            }
            
            // Agregar el indicador al contenedor
            buttonContainer.appendChild(indicator);
            
            // Reemplazar el bot√≥n original con el contenedor
            const originalButtonContainer = headerContainer.querySelector('.flex.items-center.gap-3');
            if (originalButtonContainer) {
                originalButtonContainer.remove();
            }
            headerContainer.appendChild(buttonContainer);
        }
    }
    
    const colorClasses = {
        'green': 'bg-green-600',
        'blue': 'bg-blue-600'
    };
    
    // Agregar informaci√≥n sobre el tipo de sesi√≥n
    const sessionType = 'Sesi√≥n Persistente';
    const sessionIcon = 'ph-infinity';
    
    indicator.className = `px-3 py-1 rounded-full text-white text-sm font-medium shadow-lg ${colorClasses[color]}`;
    indicator.innerHTML = `<i class="ph ph-user-circle mr-1"></i>${role} <i class="ph ${sessionIcon} ml-1" title="${sessionType}"></i>`;
}

// Funci√≥n para ocultar indicador de rol
function hideRoleIndicator() {
    const indicator = document.getElementById('role-indicator');
    if (indicator) {
        indicator.remove();
    }
}

// Funci√≥n para actualizar el estado del bot√≥n de entrada/salida
function updateExitButtonState(isAuthenticated) {
    const exitButton = document.getElementById('exit-admin-button');
    if (exitButton) {
        if (isAuthenticated) {
            // Usuario autenticado - mostrar "Salir del panel"
            exitButton.textContent = 'Salir del panel';
            exitButton.className = 'text-sm font-medium bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg';
        } else {
            // Usuario no autenticado - mostrar "Entrar al panel"
            exitButton.textContent = 'Entrar al panel';
            exitButton.className = 'text-sm font-medium bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg';
        }
    }
}

// Funci√≥n para configurar sesi√≥n temporal (Administrador)
function setupTemporarySession() {
    // Limpiar timeout anterior si existe
    if (sessionTimeout) {
        clearTimeout(sessionTimeout);
    }
    
    // Configurar timeout de 30 minutos para administrador
    sessionTimeout = setTimeout(() => {
        logoutUser('Sesi√≥n de administrador expirada por seguridad.');
    }, 30 * 60 * 1000); // 30 minutos
    
    console.log('üîí [ADMIN] Sesi√≥n temporal configurada (30 minutos)');
}

// Funci√≥n para configurar sesi√≥n persistente (Observador)
function setupPersistentSession() {
    // Limpiar timeout anterior si existe
    if (sessionTimeout) {
        clearTimeout(sessionTimeout);
        sessionTimeout = null;
    }
    

}

// Funci√≥n para cerrar sesi√≥n
function logoutUser(message = 'Sesi√≥n cerrada.') {
    // Limpiar todos los timers y listeners
    cleanupAllTimers();
    
    // Limpiar variables de sesi√≥n
    currentUserRole = null;
    isAuthenticated = false;
    window._forceAdminActive = false;
    
    // Limpiar timeout
    if (sessionTimeout) {
        clearTimeout(sessionTimeout);
        sessionTimeout = null;
    }
    
    // Ocultar panel
    const adminPanel = document.getElementById('admin-panel-container');
    if (adminPanel) adminPanel.style.display = 'none';
    
    // Mostrar modal de login
    const loginModal = document.getElementById('admin-login-modal');
    if (loginModal) {
        loginModal.classList.remove('hidden');
        loginModal.classList.add('flex');
    }
    
    // Limpiar indicador de rol
    hideRoleIndicator();
    
    // Limpiar contrase√±a
    const passwordInput = document.getElementById('admin-password');
    if (passwordInput) passwordInput.value = '';
    
    // Cambiar el bot√≥n a "Entrar al panel"
    updateExitButtonState(false);
    
    // Limpiar clases del body
    document.body.classList.remove('admin-mode', 'observer-mode');
    
    // Mostrar mensaje si se proporciona
    if (message) {
        const loginError = document.getElementById('admin-login-error');
        if (loginError) {
            loginError.textContent = message;
            setTimeout(() => {
                loginError.textContent = '';
            }, 5000);
        }
    }
    
    console.log('üëã Usuario deslogueado - Sistema limpiado');
}

// Funci√≥n para habilitar todas las funcionalidades (admin)
function enableAllFeatures() {
    // Asegurar que el rol est√© establecido correctamente
    currentUserRole = 'admin';
    console.log('‚úÖ Rol establecido como admin en enableAllFeatures');
    
    // Agregar clase al body para activar estilos CSS
    document.body.classList.add('admin-mode');
    document.body.classList.remove('observer-mode');
    
    // Mostrar todos los botones y funcionalidades
    const observerOnlyElements = document.querySelectorAll('.observer-only');
    observerOnlyElements.forEach(el => el.style.display = 'none');
    
    const adminElements = document.querySelectorAll('.admin-only');
    adminElements.forEach(el => el.style.display = 'block');
}

// Funci√≥n para habilitar solo funcionalidades de observador
function enableObserverFeatures() {
    // Agregar clase al body para activar estilos CSS
    document.body.classList.add('observer-mode');
    document.body.classList.remove('admin-mode');
    
    // Ocultar funcionalidades de admin
    const adminElements = document.querySelectorAll('.admin-only');
    adminElements.forEach(el => el.style.display = 'none');
    
    // Mostrar solo funcionalidades de observador
    const observerOnlyElements = document.querySelectorAll('.observer-only');
    observerOnlyElements.forEach(el => el.style.display = 'block');
}

// Llama a la funci√≥n de setup de login al cargar el JS
setupAdminLogin();

// Funci√≥n para verificar el estado del rol
function checkUserRole() {
    console.log('üîç Verificando rol del usuario...');
    console.log('Rol actual:', currentUserRole);
    console.log('¬øEst√° autenticado?:', isAuthenticated);
    console.log('¬øTiene clase admin-mode?:', document.body.classList.contains('admin-mode'));
    console.log('¬øTiene clase observer-mode?:', document.body.classList.contains('observer-mode'));
}

// ========== INICIALIZACI√ìN PRINCIPAL ==========
window.addEventListener('DOMContentLoaded', async () => {
  try {
    await signInAnonymously(auth);
    initializeAdminPanel();
    
    // Verificar rol despu√©s de la inicializaci√≥n
    setTimeout(checkUserRole, 1000);
  } catch (error) {
    console.error('Error de autenticaci√≥n Firebase:', error);
  }
});

// Registro autom√°tico del Service Worker y solicitud de permisos de notificaciones
if ('serviceWorker' in navigator) {
    // Registrar el Service Worker personalizado (para cache, etc)
    // navigator.serviceWorker.register('/sw.js', { scope: '/' })
    //     .then(reg => console.log('Service Worker registrado (sw.js):', reg))
    //     .catch(err => console.error('Error registrando Service Worker (sw.js):', err));

    // Registrar el Service Worker de Firebase para notificaciones push
    navigator.serviceWorker.register('/firebase-messaging-sw.js')
        .catch(err => console.error('Error registrando Service Worker de Firebase:', err));
}

if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
}

// Exportar funciones para uso global
window.getEl = getEl;
window.fetchAdminReservations = fetchAdminReservations;
window.updateAdminUI = updateAdminUI;
window.exportToExcel = exportToExcel;
window.deleteReservation = deleteReservation;
window.refreshPaymentStatus = refreshPaymentStatus;
window.forcePaymentStatusUpdate = forcePaymentStatusUpdate;
window.generarComprobantePDF = generarComprobantePDF;

// Funci√≥n temporal para forzar rol de admin (solo para testing)
window.forceAdminRole = function() {
    // Limpiar sistema anterior
    cleanupAllTimers();
    
    // Establecer rol de admin
    currentUserRole = 'admin';
    isAuthenticated = true;
    window._forceAdminActive = true;
    enableAllFeatures();
    showRoleIndicator('Administrador', 'green');
    console.log('üîß Rol forzado como admin');
    checkUserRole();
    
    // Reinicializar sistema de asistencias
    initializeAttendanceSystem();
    
    // Refrescar la UI para mostrar botones de asistencia
    const dateFilter = getEl('dateFilter');
    if (dateFilter && dateFilter.value) {
        fetchAdminReservations(dateFilter.value, 'daily');
    }
};

// Funci√≥n para limpiar todo el sistema
window.cleanupSystem = function() {
    cleanupAllTimers();
    clearSystemState();
    console.log('üßπ Sistema completamente limpiado');
};

// Funci√≥n para debuggear el estado de las reservas
window.debugReservations = function() {
    console.log('üîç Debug de reservas:');
    console.log('allReservations:', allReservations.length);
    console.log('currentFilter:', currentFilter);
    console.log('¬øHay filtro activo?:', currentFilter !== 'all' && currentFilter !== '');
    console.log('Primeras 3 reservas:', allReservations.slice(0, 3));
    console.log('Flag de actualizaci√≥n:', window._isUpdatingFromListener);
};

// Funci√≥n para forzar la restauraci√≥n de reservas
window.forceRestoreReservations = function() {
    const dateFilter = getEl('dateFilter');
    if (dateFilter && dateFilter.value) {
        console.log('üîÑ Forzando restauraci√≥n de reservas...');
        // NO llamar a fetchAdminReservations porque crea un nuevo listener
        // En su lugar, usar el listener existente
        if (window._adminReservationsUnsub) {
            console.log('üîÑ Usando listener existente para restaurar reservas');
            // El listener existente ya deber√≠a estar funcionando
            // Solo forzar una actualizaci√≥n de la UI con las reservas actuales
            if (allReservations.length > 0) {
                console.log(`üîÑ Restaurando ${allReservations.length} reservas desde cache`);
                updateAdminUI(allReservations, 'FILTER_UPDATE', 'Restaurado desde cache');
            } else {
                console.log('‚ö†Ô∏è No hay reservas en cache para restaurar');
            }
        } else {
            console.log('üîÑ Creando nuevo listener para restaurar reservas');
            fetchAdminReservations(dateFilter.value, 'daily');
        }
    }
};

// Funci√≥n para verificar y corregir el estado de las reservas
window.checkAndFixReservations = function() {
    console.log('üîç Verificando estado de reservas...');
    console.log('allReservations:', allReservations.length);
    console.log('currentFilter:', currentFilter);
    console.log('Listener activo:', !!window._adminReservationsUnsub);
    console.log('Flag de actualizaci√≥n:', window._isUpdatingFromListener);
    
    // Si no hay reservas pero deber√≠a haberlas, forzar restauraci√≥n
    if (allReservations.length === 0 && window._adminReservationsUnsub) {
        console.log('‚ö†Ô∏è No hay reservas pero hay listener activo, forzando restauraci√≥n...');
        window.forceRestoreReservations();
    }
};

// Funci√≥n para verificar el estado del listener
window.debugListenerState = function() {
    console.log('üîç Debug del estado del listener:');
    console.log('_firestoreUnsubscribe:', !!window._firestoreUnsubscribe);
    console.log('_adminReservationsUnsub:', !!window._adminReservationsUnsub);
    console.log('_isUpdatingFromListener:', window._isUpdatingFromListener);
    console.log('allReservations.length:', allReservations.length);
    console.log('currentFilter:', currentFilter);
    
    // Verificar si hay m√∫ltiples listeners activos
    if (window._firestoreUnsubscribe && window._adminReservationsUnsub) {
        console.log('‚ö†Ô∏è ADVERTENCIA: Hay m√∫ltiples listeners activos');
    }
};

// Funci√≥n para restaurar filtros y reservas
window.restoreFiltersAndReservations = function() {
    console.log('üîÑ Restaurando filtros y reservas...');
    
    // Verificar que los filtros est√©n visibles
    const filterCards = document.querySelectorAll('.filter-card');
    console.log(`üîç Encontrados ${filterCards.length} filtros en el DOM`);
    
    if (filterCards.length === 0) {
        console.log('‚ö†Ô∏è No se encontraron filtros en el DOM');
        return;
    }
    
    // Si no hay reservas, intentar obtenerlas
    if (allReservations.length === 0) {
        console.log('‚ö†Ô∏è No hay reservas, intentando obtenerlas...');
        const dateFilter = getEl('dateFilter');
        if (dateFilter && dateFilter.value) {
            const currentDate = dateFilter.value;
            const reservationsRef = collection(db, "reservations");
            const q = query(reservationsRef, where('date', '==', currentDate));
            
            getDocs(q).then((snapshot) => {
                const reservations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const filteredReservations = reservations.filter(res => res.name && res.date && res.time);
                filteredReservations.sort((a, b) => {
                    const dateA = new Date(`${a.date}T${a.time}`);
                    const dateB = new Date(`${b.date}T${b.time}`);
                    return dateA - dateB;
                });
                
                allReservations = [...filteredReservations];
                console.log(`‚úÖ Restauradas ${allReservations.length} reservas`);
                
                // Aplicar filtro actual si existe
                if (currentFilter && currentFilter !== 'all') {
                    applyFilter(currentFilter);
                } else {
                    updateAdminUI(allReservations, 'FILTER_UPDATE', 'Restaurado');
                }
            }).catch((error) => {
                console.error('Error restaurando reservas:', error);
            });
        }
    } else {
        console.log(`‚úÖ Ya hay ${allReservations.length} reservas, aplicando filtro actual`);
        // Aplicar filtro actual si existe
        if (currentFilter && currentFilter !== 'all') {
            applyFilter(currentFilter);
        } else {
            updateAdminUI(allReservations, 'FILTER_UPDATE', 'Restaurado');
        }
    }
}; 

// MODAL DE √âXITO TRAS ELIMINAR RESERVA (ADMIN)
function showSuccessDeleteModal() {
    // Eliminar cualquier modal anterior
    const oldModal = document.getElementById('custom-modal-overlay');
    if (oldModal) oldModal.remove();
    const overlay = document.createElement('div');
    overlay.id = 'custom-modal-overlay';
    overlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50';
    overlay.style.zIndex = 9999;
    const modal = document.createElement('div');
    modal.className = 'bg-white rounded-2xl shadow-2xl p-8 max-w-sm w-full text-center relative border-2 border-green-200 animate__animated animate__fadeInDown';
    // Icono de √©xito
    const icon = document.createElement('div');
    icon.innerHTML = '<div class="flex justify-center mb-2"><span class="inline-flex items-center justify-center w-14 h-14 rounded-full bg-green-100"><svg class="w-10 h-10 text-green-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2l4 -4"/><circle cx="12" cy="12" r="9"/></svg></span></div>';
    modal.appendChild(icon);
    // T√≠tulo
    const titleEl = document.createElement('h2');
    titleEl.className = 'text-2xl font-bold mb-2 text-green-700';
    titleEl.textContent = '¬°Reserva Eliminada!';
    modal.appendChild(titleEl);
    // Mensaje
    const msgEl = document.createElement('p');
    msgEl.className = 'mb-4 text-gray-700';
    msgEl.textContent = 'La reserva fue eliminada correctamente.';
    modal.appendChild(msgEl);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    setTimeout(() => {
        if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
        }
        // Refrescar la lista de reservas
        const dateFilter = document.getElementById('dateFilter');
        const periodSelector = document.getElementById('periodSelector');
        if (dateFilter && dateFilter.value) {
            fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
        }
    }, 1000);
} 

// ========== GESTI√ìN DE D√çAS Y TURNOS ESPECIALES ==========

function setupSpecialDaysModal() {
  const openBtn = document.getElementById('open-special-days-modal');
  const modal = document.getElementById('special-days-modal');
  const closeBtn = document.getElementById('close-special-days-modal');
  const form = document.getElementById('special-days-form');
  const dateInput = document.getElementById('special-day-date');
  const lunchOpen = document.getElementById('special-lunch-open');
  const dinnerOpen = document.getElementById('special-dinner-open');
  const lunchClose = document.getElementById('special-lunch-close');
  const dinnerClose = document.getElementById('special-dinner-close');
  const list = document.getElementById('special-days-list');

  // Abrir modal
  openBtn.addEventListener('click', () => {
    modal.classList.remove('hidden');
    loadSpecialDaysList();
  });
  // Cerrar modal
  closeBtn.addEventListener('click', () => {
    modal.classList.add('hidden');
    form.reset();
  });
  // Validar que no se pueda abrir y cerrar el mismo turno a la vez
  lunchOpen.addEventListener('change', () => { if (lunchOpen.checked) lunchClose.checked = false; });
  lunchClose.addEventListener('change', () => { if (lunchClose.checked) lunchOpen.checked = false; });
  dinnerOpen.addEventListener('change', () => { if (dinnerOpen.checked) dinnerClose.checked = false; });
  dinnerClose.addEventListener('change', () => { if (dinnerClose.checked) dinnerOpen.checked = false; });

  // Guardar configuraci√≥n
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const fecha = dateInput.value;
    if (!fecha) return showSimpleMessage('Selecciona una fecha', 'error');
    const data = {
      fecha,
      almuerzo: lunchOpen.checked ? 'abierto' : (lunchClose.checked ? 'cerrado' : null),
      cena: dinnerOpen.checked ? 'abierto' : (dinnerClose.checked ? 'cerrado' : null)
    };
    if (!data.almuerzo && !data.cena) return showSimpleMessage('Selecciona al menos un turno para abrir o cerrar', 'error');
    await setDoc(doc(collection(db, 'turnosEspeciales'), fecha), data);
    form.reset();
    loadSpecialDaysList();
    showSimpleMessage('D√≠a especial guardado', 'success');
  });

  // Funci√≥n para mostrar mensajes simples en el modal
  function showSimpleMessage(message, type = 'info') {
    // Crear o actualizar el elemento de mensaje
    let messageEl = document.getElementById('special-days-message');
    if (!messageEl) {
      messageEl = document.createElement('div');
      messageEl.id = 'special-days-message';
      messageEl.className = 'w-full text-center p-2 rounded-lg mb-2';
      form.parentNode.insertBefore(messageEl, form);
    }
    
    const colors = {
      success: 'bg-green-100 text-green-800',
      error: 'bg-red-100 text-red-800',
      info: 'bg-blue-100 text-blue-800'
    };
    
    messageEl.className = `w-full text-center p-2 rounded-lg mb-2 ${colors[type]}`;
    messageEl.textContent = message;
    
    // Auto-ocultar despu√©s de 3 segundos
    setTimeout(() => {
      if (messageEl && messageEl.parentNode) {
        messageEl.remove();
      }
    }, 3000);
  }

  // Cargar lista de d√≠as especiales
  async function loadSpecialDaysList() {
    list.innerHTML = '<li class="text-gray-400 text-sm sm:text-base">Cargando...</li>';
    const snap = await getDocs(collection(db, 'turnosEspeciales'));
    if (snap.empty) {
      list.innerHTML = '<li class="text-gray-400 text-sm sm:text-base">No hay d√≠as especiales configurados</li>';
      return;
    }
    list.innerHTML = '';
    snap.forEach(docSnap => {
      const d = docSnap.data();
      const fecha = d.fecha;
      // Siempre mostrar ambos turnos, aunque uno est√© vac√≠o
      const almuerzoEstado = d.almuerzo ? `<span class='${d.almuerzo === 'abierto' ? 'text-green-600' : 'text-red-600'}'>${d.almuerzo}</span>` : `<span class='text-gray-400'>-</span>`;
      const cenaEstado = d.cena ? `<span class='${d.cena === 'abierto' ? 'text-green-600' : 'text-red-600'}'>${d.cena}</span>` : `<span class='text-gray-400'>-</span>`;
      let desc = `<span class='font-semibold text-xs sm:text-sm'>${fecha}</span>: <span class='text-xs sm:text-sm'>Almuerzo ${almuerzoEstado} <span class='text-gray-400'>|</span> Cena ${cenaEstado}</span>`;
      list.innerHTML += `<li class='flex items-center justify-between gap-1 sm:gap-2 bg-gray-100 rounded px-2 py-1.5 sm:px-3 sm:py-2 text-xs sm:text-sm'>${desc}<button data-fecha='${fecha}' class='delete-special-day text-red-600 hover:text-red-800 ml-1 sm:ml-2 p-1'><i class='ph ph-trash text-sm sm:text-base'></i></button></li>`;
    });
    // Botones de eliminar
    list.querySelectorAll('.delete-special-day').forEach(btn => {
      btn.addEventListener('click', async () => {
        const fecha = btn.getAttribute('data-fecha');
        // Eliminar directamente y mostrar mensaje simple
        await deleteDoc(doc(collection(db, 'turnosEspeciales'), fecha));
        loadSpecialDaysList();
        showSimpleMessage('D√≠a especial eliminado', 'success');
      });
    });
  }
}

// ========== MODAL DE EDICI√ìN DE RESERVAS ==========

async function openEditModal(reservationId) {
  try {
    if (!reservationId) {
      alert('Error: No se pudo identificar la reserva a editar');
      return;
    }
    const docRef = doc(db, "reservations", reservationId);
    const docSnap = await getDoc(docRef);
    if (!docSnap.exists()) {
      alert('Reserva no encontrada');
      return;
    }
    const resData = docSnap.data();
    // Eliminar cualquier modal anterior
    const oldModal = document.getElementById('custom-modal-overlay');
    if (oldModal) oldModal.remove();
    // Crear overlay y modal
    const overlay = document.createElement('div');
    overlay.id = 'custom-modal-overlay';
    overlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50 p-4';
    overlay.style.zIndex = 9999;
    const modal = document.createElement('div');
    modal.className = 'bg-white rounded-2xl shadow-2xl p-4 sm:p-6 md:p-8 w-full max-w-lg max-h-[90vh] overflow-y-auto relative';
    // Bot√≥n de cerrar - siempre visible y bien posicionado
    const closeBtn = document.createElement('button');
    closeBtn.className = 'absolute top-2 right-2 text-gray-500 hover:text-gray-700 transition-colors z-50 bg-white rounded-full p-1 shadow-sm';
    closeBtn.innerHTML = '<i class="ph ph-x text-xl"></i>';
    closeBtn.onclick = () => { 
        if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
        }
    };
    modal.appendChild(closeBtn);
    // Header
    const header = document.createElement('div');
    header.className = 'text-center mb-6 sm:mb-8 pt-2';
    header.innerHTML = `
      <div class="flex justify-center mb-3 sm:mb-4">
        <span class="inline-flex items-center justify-center w-12 h-12 sm:w-16 sm:h-16 rounded-full bg-green-100">
          <i class="ph ph-pencil-simple text-2xl sm:text-3xl text-green-600"></i>
        </span>
      </div>
      <h2 class="text-xl sm:text-2xl font-bold text-green-700">Editar Reserva</h2>
      <p class="text-sm sm:text-base text-gray-600 mt-1 sm:mt-2">Modifica los datos de la reserva</p>
    `;
    modal.appendChild(header);
    // Formulario
    const form = document.createElement('form');
    form.className = 'space-y-4 sm:space-y-6';
    // Secci√≥n: Tus Datos
    const datosSection = document.createElement('div');
    datosSection.className = 'space-y-3 sm:space-y-4';
    datosSection.innerHTML = `
      <h3 class="text-base sm:text-lg font-semibold text-gray-800 border-b pb-2">Tus Datos</h3>
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Nombre y Apellido</label>
          <input type="text" name="name" value="${resData.name || ''}" required class="w-full p-2 sm:p-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-600 text-sm sm:text-base">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Tel√©fono</label>
          <input type="tel" name="phone" value="${resData.phone || ''}" required class="w-full p-2 sm:p-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-600 text-sm sm:text-base">
        </div>
      </div>
    `;
    form.appendChild(datosSection);
    // Secci√≥n: Detalles de la Reserva
    const reservaSection = document.createElement('div');
    reservaSection.className = 'space-y-3 sm:space-y-4';
    reservaSection.innerHTML = `
      <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 sm:gap-6">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Fecha</label>
          <input type="date" name="date" value="${resData.date || ''}" required class="w-full p-2 sm:p-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-600 text-sm sm:text-base">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Hora</label>
          <input type="time" name="time" value="${resData.time || ''}" required class="w-full p-2 sm:p-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-600 text-sm sm:text-base">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Comensales</label>
          <input type="number" name="diners" value="${resData.diners || 2}" min="1" required class="w-full p-2 sm:p-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-600 text-sm sm:text-base">
        </div>
      </div>
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6 mt-4">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">√Årea</label>
          <select name="area" class="w-full p-2 sm:p-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-600 text-sm sm:text-base">
            <option value="" ${!resData.area ? 'selected' : ''}>Seleccionar...</option>
            <option value="Sal√≥n" ${resData.area === 'Sal√≥n' ? 'selected' : ''}>Sal√≥n</option>
            <option value="Patio" ${resData.area === 'Patio' ? 'selected' : ''}>Patio</option>
          </select>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Notas</label>
          <textarea name="notes" rows="2" class="w-full p-2 sm:p-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-600 text-sm sm:text-base">${resData.notes || ''}</textarea>
        </div>
      </div>
    `;
    form.appendChild(reservaSection);
    // Mensaje de error
    const errorEl = document.createElement('div');
    errorEl.className = 'text-red-600 text-sm hidden';
    form.appendChild(errorEl);
    // Bot√≥n guardar
    const btnGroup = document.createElement('div');
    btnGroup.className = 'mt-6 sm:mt-8';
    const saveBtn = document.createElement('button');
    saveBtn.type = 'submit';
    saveBtn.className = 'w-full bg-green-700 text-white font-bold py-2 sm:py-3 px-4 rounded-lg hover:bg-green-800 focus:outline-none focus:ring-4 focus:ring-green-500 transition-transform transform hover:scale-105 flex items-center justify-center gap-2 text-sm sm:text-base';
    saveBtn.innerHTML = '<i class="ph ph-check-circle text-lg sm:text-xl"></i>Guardar Cambios';
    btnGroup.appendChild(saveBtn);
    form.appendChild(btnGroup);
    modal.appendChild(form);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    // Validaci√≥n y guardado
    form.onsubmit = async (e) => {
      e.preventDefault();
      errorEl.classList.add('hidden');
      const formData = new FormData(form);
      const name = formData.get('name').trim();
      const phone = formData.get('phone').trim();
      const date = formData.get('date');
      const time = formData.get('time');
      const diners = parseInt(formData.get('diners'), 10);
      const area = formData.get('area');
      const notes = formData.get('notes');
      // Validaciones
      if (!name || !phone || !date || !time || diners < 1) {
        errorEl.textContent = 'Por favor, completa todos los campos requeridos.';
        errorEl.classList.remove('hidden');
        return;
      }
      const now = new Date();
      const reservationDateTime = new Date(`${date}T${time}`);
      if (reservationDateTime < now) {
        errorEl.textContent = 'No puedes reservar para una fecha u hora que ya ha pasado.';
        errorEl.classList.remove('hidden');
        return;
      }
      if (reservationDateTime.toDateString() === now.toDateString() && (reservationDateTime.getTime() - now.getTime()) / 60000 < 30) {
        errorEl.textContent = 'Debes reservar con al menos 30 minutos de anticipaci√≥n.';
        errorEl.classList.remove('hidden');
        return;
      }
      // Validar horario fuera de apertura (usando validateReservationTime)
      if (typeof validateReservationTime === 'function') {
        const valid = await validateReservationTime(date, time, 'client', errorEl);
        if (!valid) {
          errorEl.textContent = 'El restaurante no est√° abierto en el horario seleccionado.';
          errorEl.classList.remove('hidden');
          return;
        }
      }
      // Guardar en Firestore
      try {
        await updateDoc(docRef, {
          name,
          phone,
          date,
          time,
          diners,
          area,
          notes,
          updatedAt: new Date().toISOString()
        });
        showSuccessModal('Reserva actualizada correctamente.');
        setTimeout(() => {
          if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
          // Refrescar la lista de reservas
          const dateFilter = document.getElementById('dateFilter');
          const periodSelector = document.getElementById('periodSelector');
          if (dateFilter && dateFilter.value) {
            fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
          }
        }, 1000);
      } catch (error) {
        errorEl.textContent = 'Error al actualizar la reserva. Intenta de nuevo.';
        errorEl.classList.remove('hidden');
        console.error('‚ùå [EDIT_RESERVATION] Error al actualizar reserva:', error);
      }
    };
  } catch (error) {
    console.error('Error al abrir modal de edici√≥n:', error);
    alert('Error al cargar los datos de la reserva: ' + error.message);
  }
}

// Funci√≥n para mostrar mensajes en el modal de edici√≥n
function showEditMessage(message, type = 'info') {
  const messageArea = document.getElementById('edit-message-area');
  if (!messageArea) return;
  
  const colors = {
    success: 'bg-green-100 text-green-800',
    error: 'bg-red-100 text-red-800',
    info: 'bg-blue-100 text-blue-800'
  };
  
  messageArea.innerHTML = `<div class="${colors[type]} p-3 rounded-lg text-sm">${message}</div>`;
  
  // Auto-ocultar despu√©s de 3 segundos
  setTimeout(() => {
    messageArea.innerHTML = '';
  }, 3000);
}

// ========== HISTORIAL DE CANCELACIONES (ADMIN) ==========
function setupCancellationsHistoryModal() {
    const openBtn = document.getElementById('open-cancellations-history-modal');
    const closeBtn = document.getElementById('close-cancellations-history-modal');
    const modal = document.getElementById('cancellations-history-modal');
    const listDiv = document.getElementById('cancellations-history-list');
    const searchInput = document.getElementById('cancellations-search-input');

    if (!openBtn || !closeBtn || !modal || !listDiv || !searchInput) return;

    let unsubscribe = null;

    openBtn.onclick = () => {
        modal.classList.remove('hidden');
        listDiv.innerHTML = '<div class="text-center text-gray-500 py-8">Cargando historial...</div>';
        // Escuchar en tiempo real
        if (unsubscribe) unsubscribe();
        unsubscribe = onSnapshot(collection(db, 'cancellations'), (snapshot) => {
            let cancellations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            // Ordenar por fecha de cancelaci√≥n descendente
            cancellations = cancellations.sort((a, b) => new Date(b.cancelledAt) - new Date(a.cancelledAt));
        renderCancellationsList(cancellations, listDiv);
        searchInput.value = '';
        searchInput.oninput = () => {
            const filtered = filterCancellations(cancellations, searchInput.value);
            renderCancellationsList(filtered, listDiv);
        };
        });
    };
    closeBtn.onclick = () => {
        modal.classList.add('hidden');
        if (unsubscribe) unsubscribe();
    };
}

async function fetchCancellations() {
    try {
        const snapshot = await getDocs(collection(db, 'cancellations'));
        const list = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        // Ordenar por fecha de cancelaci√≥n descendente
        return list.sort((a, b) => new Date(b.cancelledAt) - new Date(a.cancelledAt));
    } catch (e) {
        return [];
    }
}

function renderCancellationsList(cancellations, container) {
    if (!cancellations.length) {
        container.innerHTML = '<div class="text-center text-gray-500 py-8">No hay cancelaciones registradas.</div>';
        return;
    }
    container.innerHTML = cancellations.map(c => `
        <div class="border-b py-3 px-2 flex flex-col sm:flex-row sm:items-center gap-2">
            <div class="flex-1">
                <div class="font-semibold text-gray-800">${c.name || '-'} <span class="text-xs text-gray-500">(${c.phone || '-'})</span></div>
                <div class="text-sm text-gray-600">Reserva: ${c.date || '-'} ${c.time || ''} | Comensales: ${c.diners || '-'}${c.area ? ' | √Årea: ' + c.area : ''}</div>
                ${c.notes ? `<div class="text-xs text-gray-700 mt-1">Notas: ${c.notes}</div>` : ''}
                <div class="text-xs text-gray-400">Cancelada: ${formatDateTime(c.cancelledAt)}</div>
                ${c.motivo ? `<div class="text-xs text-red-700 mt-1">Motivo: ${c.motivo}</div>` : ''}
            </div>
            <div class="flex flex-col items-end gap-1">
            <div class="text-xs text-gray-400">ID: ${c.reservationId}</div>
                <button class="delete-cancellation-btn bg-red-100 text-red-700 px-2 py-1 rounded text-xs mt-1" data-cancel-id="${c.id}">Eliminar</button>
            </div>
        </div>
    `).join('');
    // Agregar eventos a los botones de eliminar
    container.querySelectorAll('.delete-cancellation-btn').forEach(btn => {
        btn.onclick = async () => {
            const cancelId = btn.getAttribute('data-cancel-id');
            if (cancelId && confirm('¬øEliminar este registro del historial de cancelaciones de forma permanente?')) {
                await deleteDoc(doc(db, 'cancellations', cancelId));
                showSuccessModal('Cancelaci√≥n eliminada del historial');
                // Refrescar la lista
                const cancellations = await fetchCancellations();
                renderCancellationsList(cancellations, container);
            }
        };
    });
}

function filterCancellations(cancellations, search) {
    if (!search) return cancellations;
    const s = search.toLowerCase();
    return cancellations.filter(c =>
        (c.name && c.name.toLowerCase().includes(s)) ||
        (c.phone && c.phone.includes(s)) ||
        (c.date && c.date.includes(s)) ||
        (c.motivo && c.motivo.toLowerCase().includes(s))
    );
}

function formatDateTime(dt) {
    if (!dt) return '-';
    const d = new Date(dt);
    return d.toLocaleString('es-AR', { dateStyle: 'short', timeStyle: 'short' });
}

// Inicializar el historial de cancelaciones al cargar el admin
window.addEventListener('DOMContentLoaded', setupCancellationsHistoryModal);

// MODAL DE √âXITO ANIMADO UNIVERSAL (versi√≥n fluida)
function showSuccessModal(message = "Acci√≥n realizada correctamente.") {
    const modal = document.getElementById('success-modal');
    const messageEl = document.getElementById('success-modal-message');
    
    if (!modal || !messageEl) {
        console.error('Modal de √©xito no encontrado');
        alert(message);
        return;
    }
    
    messageEl.textContent = message;
    modal.classList.remove('hidden');
    
    // Auto-cerrar despu√©s de 1 segundo
  setTimeout(() => {
        modal.classList.add('hidden');
  }, 1000);
} 

// Funci√≥n para configurar el modal de edici√≥n
function setupEditModal() {
  const editModal = document.getElementById('editModal');
  const closeEditBtn = document.getElementById('closeEditModal');
  const editForm = document.getElementById('editForm');
  
  if (!editModal || !closeEditBtn || !editForm) {
    console.warn('Elementos del modal de edici√≥n no encontrados');
    return;
  }
  
  // Cerrar modal
  closeEditBtn.onclick = () => {
    editModal.classList.add('hidden');
  };
  
  // Cerrar al hacer clic fuera del modal
  editModal.onclick = (e) => {
    if (e.target === editModal) {
      editModal.classList.add('hidden');
    }
  };
  
  // Manejar env√≠o del formulario
  editForm.onsubmit = async (e) => {
    e.preventDefault();
    await handleEditFormSubmit();
  };
  
  console.log('‚úÖ Modal de edici√≥n configurado correctamente');
}

// Funci√≥n para manejar el env√≠o del formulario de edici√≥n
async function handleEditFormSubmit() {
  try {
    const formData = new FormData(document.getElementById('editForm'));
    const reservationId = formData.get('reservationId');
    
    if (!reservationId) {
      showEditMessage('Error: ID de reserva no encontrado', 'error');
      return;
    }
    
    // Obtener datos del formulario
    const time = formData.get('editTime');
    const updatedData = {
      name: formData.get('editName'),
      phone: formData.get('editPhone'),
      date: formData.get('editDate'),
      time: time,
      turn: calcularTurnoPorHora(time), // Calcular turno autom√°ticamente
      diners: parseInt(formData.get('editDiners')),
      area: formData.get('editArea'),
      notes: formData.get('editNotes')
    };
    
    // Validar datos
    if (!updatedData.name || !updatedData.phone || !updatedData.date || !updatedData.time || !updatedData.diners) {
      showEditMessage('Por favor complete todos los campos obligatorios', 'error');
      return;
    }
    
    // Verificar que la reserva existe
    const reservationRef = doc(db, 'reservations', reservationId);
    const reservationDoc = await getDoc(reservationRef);
    
    if (!reservationDoc.exists()) {
      showEditMessage('La reserva no existe o ya fue cancelada', 'error');
      return;
    }
    
    // Obtener datos originales para la notificaci√≥n
    const originalData = reservationDoc.data();
    
    // Actualizar la reserva
    await updateDoc(reservationRef, {
      ...updatedData,
      updatedAt: serverTimestamp()
    });
    
    // Enviar notificaci√≥n de modificaci√≥n
    const notificationData = {
      ...updatedData,
      id: reservationId,
      createdBy: originalData.createdBy || 'admin',
      notificationType: 'modified'
    };
    await sendNewReservationNotification(notificationData);
    
    showEditMessage('Reserva actualizada correctamente', 'success');
    
    // Cerrar modal despu√©s de 1 segundo
    setTimeout(() => {
      document.getElementById('editModal').classList.add('hidden');
      // Recargar la lista de reservas
      const dateFilter = document.getElementById('dateFilter');
      const periodSelector = document.getElementById('periodSelector');
      if (dateFilter && dateFilter.value) {
        fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
      }
    }, 1000);
    
  } catch (error) {
    console.error('Error al actualizar reserva:', error);
    showEditMessage('Error al actualizar la reserva: ' + error.message, 'error');
  }
}

// Inicializar la gesti√≥n de d√≠as especiales al cargar el admin
window.addEventListener('DOMContentLoaded', () => {
  setupSpecialDaysModal();
  setupEditModal();
  setupCancellationsHistoryModal();
});

// Funci√≥n para manejar clics en botones de acci√≥n de reservas
function setupReservationActionButtons() {
  // Delegaci√≥n de eventos para botones de editar y eliminar
  document.addEventListener('click', async (e) => {
    const editBtn = e.target.closest('.edit-res-btn');
    const deleteBtn = e.target.closest('.delete-res-btn');
    
    if (editBtn) {
      const reservationId = editBtn.dataset.id;
      if (reservationId && reservationId.length === 20) {
        await openEditModal(reservationId);
      }
      // Si no, no hacer nada
    } else if (deleteBtn) {
      // Usar siempre firestoreId si existe
      const firestoreId = deleteBtn.dataset.firestoreId;
      const reservationId = firestoreId && firestoreId.length === 20 ? firestoreId : deleteBtn.dataset.id;
      if (reservationId) {
        // Buscar los datos de la reserva para mostrar en el modal de confirmaci√≥n
        const reservationRow = deleteBtn.closest('tr');
        let reservationData = { id: reservationId };
        if (reservationRow) {
          const nameCell = reservationRow.querySelector('td:nth-child(1)');
          const dateCell = reservationRow.querySelector('td:nth-child(3)');
          const timeCell = reservationRow.querySelector('td:nth-child(4)');
          const dinersCell = reservationRow.querySelector('td:nth-child(5)');
          if (nameCell) reservationData.name = nameCell.textContent?.trim();
          if (dateCell) reservationData.date = dateCell.textContent?.trim();
          if (timeCell) reservationData.time = timeCell.textContent?.trim();
          if (dinersCell) reservationData.diners = dinersCell.textContent?.trim();
        }
        showAdminDeleteModalVisual(reservationData, async (reservation) => {
          try {
            await deleteReservation(reservation.id, reservation);
            // Refrescar la lista de reservas
            const dateFilter = getEl('dateFilter');
            const periodSelector = getEl('periodSelector');
            if (dateFilter && dateFilter.value) {
              fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
            }
          } catch (error) {
            alert('Error al eliminar la reserva.');
          }
        });
      }
    }
  });
}

// Llamar a la funci√≥n cuando se actualice la lista de reservas
const originalUpdateAdminUI = updateAdminUI;
updateAdminUI = function(reservations, titleDate = '', periodInfo = '') {
  originalUpdateAdminUI(reservations, titleDate, periodInfo);
  setupReservationActionButtons();
};

// ========== LIMPIAR CACH√â Y FORZAR ACTUALIZACI√ìN ==========
async function forceRefreshReservations() {
    try {
        console.log('üîÑ Forzando actualizaci√≥n completa de reservas...');
        
        // Limpiar cach√© local completamente
        if (window._adminReservationsFiltered) {
            delete window._adminReservationsFiltered;
        }
        
        // Limpiar cualquier cach√© de Firebase
        if (window.db) {
            try {
                // Forzar desconexi√≥n y reconexi√≥n de Firestore
                console.log('üîÑ Limpiando cach√© de Firestore...');
                await window.db.clearPersistence();
            } catch (e) {
                console.log('No se pudo limpiar persistencia de Firestore:', e);
            }
        }
        
        // Limpiar la interfaz completamente
        const body = getEl('reservationsTableBody');
        const mobileDiv = getEl('reservasCardsMobile');
        if (body) body.innerHTML = '<tr><td colspan="7" class="p-8 text-center text-gray-500">Actualizando...</td></tr>';
        if (mobileDiv) mobileDiv.innerHTML = '<div class="p-8 text-center text-gray-500">Actualizando...</div>';
        
        // Forzar recarga desde Firestore
        const dateFilter = getEl('dateFilter');
        const periodSelector = getEl('periodSelector');
        
        if (dateFilter && dateFilter.value) {
            console.log('üîÑ Recargando reservas desde Firestore para fecha:', dateFilter.value);
            await fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
            showSuccessModal('Lista de reservas actualizada correctamente');
        } else {
            // Si no hay fecha seleccionada, usar hoy
            const today = getLocalDateString();
            console.log('üîÑ Recargando reservas desde Firestore para hoy:', today);
            await fetchAdminReservations(today, 'daily');
            showSuccessModal('Lista de reservas actualizada correctamente');
        }
        
    } catch (error) {
        console.error('Error al forzar actualizaci√≥n:', error);
        showSuccessModal('Error al actualizar la lista de reservas: ' + error.message);
    }
}

// Funci√≥n para limpiar cach√© del navegador y recargar p√°gina
async function forceClearCacheAndReload() {
    try {
        console.log('üîÑ Limpiando cach√© del navegador y recargando...');
        
        // Limpiar cach√© local
        if (window._adminReservationsFiltered) {
            delete window._adminReservationsFiltered;
        }
        
        // Limpiar cach√© de Firebase
        if (window.db) {
            try {
                await window.db.clearPersistence();
            } catch (e) {
                console.log('No se pudo limpiar persistencia de Firestore:', e);
            }
        }
        
        // Limpiar cach√© del navegador si es posible
        if ('caches' in window) {
            try {
                const cacheNames = await caches.keys();
                await Promise.all(cacheNames.map(name => caches.delete(name)));
                console.log('üîÑ Cach√© del navegador limpiado');
            } catch (e) {
                console.log('No se pudo limpiar cach√© del navegador:', e);
            }
        }
        
        // Recargar la p√°gina
        window.location.reload(true);
        
    } catch (error) {
        console.error('Error al limpiar cach√©:', error);
        // Si falla, al menos recargar la p√°gina
        window.location.reload(true);
    }
} 

async function handleAddReservationFormSubmit(form) {
    const messageArea = getEl('add-message-area');
    const formData = new FormData(form);
    
    const name = formData.get('addName').trim();
    const countryCode = formData.get('addCountryCode');
    const phoneLocal = formData.get('addPhone').trim();
    const phone = `${countryCode}${phoneLocal}`;
    const date = formData.get('addDate');
    const time = formData.get('addTime');
    const diners = parseInt(formData.get('addDiners'), 10);
    const area = formData.get('addArea');
    const notes = formData.get('addNotes').trim();
    const seniaPagada = formData.get('addSeniaPagada');
    const montoSenia = formData.get('addMontoSenia');
    const metodoPago = formData.get('addMetodoPago');
    
    // Calcular turno autom√°ticamente seg√∫n la hora
    const turn = calcularTurnoPorHora(time);
    
    // Validaciones
    if (!name || !phone || !date || !time || diners < 1) {
        messageArea.innerHTML = '<p class="text-red-600 text-sm">Por favor, completa todos los campos requeridos.</p>';
        return;
    }
    
    // Validaciones espec√≠ficas para se√±a pagada
    if (seniaPagada === 'si') {
        if (!montoSenia || parseInt(montoSenia) <= 0) {
            messageArea.innerHTML = '<p class="text-red-600 text-sm">Si se pag√≥ la se√±a, debes especificar un monto v√°lido.</p>';
            return;
        }
        if (!metodoPago) {
            messageArea.innerHTML = '<p class="text-red-600 text-sm">Si se pag√≥ la se√±a, debes especificar el m√©todo de pago.</p>';
            return;
        }
    }
    
    const now = new Date();
    const reservationDateTime = new Date(`${date}T${time}`);
    if (reservationDateTime < now) {
        messageArea.innerHTML = '<p class="text-red-600 text-sm">No puedes reservar para una fecha u hora que ya ha pasado.</p>';
        return;
    }
    if (reservationDateTime.toDateString() === now.toDateString() && (reservationDateTime.getTime() - now.getTime()) / 60000 < 30) {
        messageArea.innerHTML = '<p class="text-red-600 text-sm">Debes reservar con al menos 30 minutos de anticipaci√≥n.</p>';
        return;
    }
    
    try {
        // Determinar el estado de pago seg√∫n si se pag√≥ la se√±a
        let paymentStatus = 'manual';
        let depositAmount = null;
        let paymentMethod = null;
        
        if (seniaPagada === 'si') {
            paymentStatus = 'pagado-manual';
            depositAmount = parseInt(montoSenia) || 0;
            paymentMethod = metodoPago || '';
        }
        
        // Determinar qui√©n cre√≥ la reserva
        const createdBy = currentUserRole === 'observer' ? 'observador' : 'admin';
        
        const newReservationData = {
            name,
            phone,
            date,
            time,
            turn,
            diners,
            area: area || '',
            notes: notes || '',
            paymentStatus: paymentStatus,
            status: paymentStatus,
            depositAmount: depositAmount,
            paymentMethod: paymentMethod,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            createdBy: createdBy
        };
        
        // Agregar a Firestore
        const docRef = await addDoc(collection(db, "reservations"), newReservationData);
        
        // Actualizar el documento con el firestoreId (solo para admin)
        await updateDoc(docRef, {
            firestoreId: docRef.id,
            id: docRef.id // Usar el mismo ID largo para admin
        });
        
        // Enviar notificaci√≥n de nueva reserva manual
        const notificationData = {
            ...newReservationData,
            id: docRef.id,
            notificationType: paymentStatus === 'pagado-manual' ? 'paid' : 'pending'
        };
        await sendNewReservationNotification(notificationData);
        
        messageArea.innerHTML = '<p class="text-green-600 text-sm">¬°Reserva creada correctamente!</p>';
        
        // Limpiar formulario
        form.reset();
        
        // Ocultar campos de se√±a despu√©s de limpiar
        const seniaDetailsDiv = getEl('addSeniaDetails');
        if (seniaDetailsDiv) {
            seniaDetailsDiv.classList.add('hidden');
        }
        
        // Cerrar modal despu√©s de 2 segundos
        setTimeout(() => {
            const modal = getEl('add-reservation-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
            messageArea.innerHTML = '';
            
            // Refrescar la lista de reservas
            const dateFilter = getEl('dateFilter');
            const periodSelector = getEl('periodSelector');
            if (dateFilter && dateFilter.value) {
                fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
            }
        }, 2000);
        
    } catch (error) {
        messageArea.innerHTML = '<p class="text-red-600 text-sm">Error al crear la reserva. Intenta de nuevo.</p>';
        console.error('‚ùå [ADD_RESERVATION] Error al crear reserva:', error);
    }
}

async function openAddReservationModal() {
    try {
        const modal = getEl('add-reservation-modal');
        if (modal) {
            modal.classList.remove('hidden');
            
            // Establecer fecha m√≠nima (hoy)
            const dateInput = modal.querySelector('#addDate');
            if (dateInput) {
                // Usar fecha local para evitar problemas de zona horaria
                const now = new Date();
                const today = now.getFullYear() + '-' + 
                             String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                             String(now.getDate()).padStart(2, '0');
                dateInput.min = today;
                dateInput.value = today;
                console.log('‚úÖ [ADMIN_MODAL] Fecha m√≠nima configurada:', today);
            }
            
            // Limpiar mensajes anteriores
            const messageArea = getEl('add-message-area');
            if (messageArea) {
                messageArea.innerHTML = '';
            }
        }
    } catch (error) {
        console.error('Error al abrir modal de agregar reserva:', error);
        alert('Error al abrir el formulario: ' + error.message);
    }
}

// Loader para la tabla de reservas
function showReservationsLoader() {
  const body = getEl('reservationsTableBody');
  const mobileDiv = getEl('reservasCardsMobile');
  if (body) {
    body.innerHTML = '<tr><td colspan="7" class="p-8 text-center text-gray-400 animate-pulse">Cargando reservas...</td></tr>';
  }
  if (mobileDiv) {
    mobileDiv.innerHTML = '<div class="p-8 text-center text-gray-400 animate-pulse" style="min-height:200px;">Cargando reservas...</div>';
  }
}

// Variables de paginaci√≥n
let pageSize = 10;
let lastVisible = null;
let firstVisible = null;
let currentPage = 1;
let totalPages = 1;
let pageCursors = [];
let currentQuery = null;
let currentPeriodType = 'daily';
let currentDateString = '';

// Manejar cambio de cantidad por p√°gina
const pageSizeSelector = document.getElementById('pageSizeSelector');
if (pageSizeSelector) {
  pageSizeSelector.addEventListener('change', () => {
    pageSize = parseInt(pageSizeSelector.value, 10);
    currentPage = 1;
    pageCursors = [];
    fetchAdminReservations(currentDateString, currentPeriodType, true);
  });
}

// Botones de paginaci√≥n
function renderPaginationControls() {
  const controls = document.getElementById('paginationControls');
  if (!controls) return;
  controls.innerHTML = '';
  // Bot√≥n anterior
  const prevBtn = document.createElement('button');
  prevBtn.textContent = 'Anterior';
  prevBtn.className = 'px-3 py-1 rounded bg-gray-200 text-gray-700 hover:bg-gray-300 disabled:opacity-50';
  prevBtn.disabled = currentPage === 1;
  prevBtn.onclick = () => goToPage(currentPage - 1);
  controls.appendChild(prevBtn);
  // Info de p√°gina
  const info = document.createElement('span');
  info.textContent = `P√°gina ${currentPage} de ${totalPages}`;
  info.className = 'mx-2 text-sm text-gray-600';
  controls.appendChild(info);
  // Bot√≥n siguiente
  const nextBtn = document.createElement('button');
  nextBtn.textContent = 'Siguiente';
  nextBtn.className = 'px-3 py-1 rounded bg-gray-200 text-gray-700 hover:bg-gray-300 disabled:opacity-50';
  nextBtn.disabled = currentPage === totalPages;
  nextBtn.onclick = () => goToPage(currentPage + 1);
  controls.appendChild(nextBtn);
}

function goToPage(page) {
  if (page < 1 || page > totalPages) return;
  currentPage = page;
  fetchAdminReservations(currentDateString, currentPeriodType, false);
}



// L√≥gica para men√∫ flotante de exportar todas
const exportBtn = document.getElementById('export-excel-btn');
const exportAllMenu = document.getElementById('export-all-menu');
const exportAllBtn = document.getElementById('export-all-btn');
let exportMenuTimeout = null;

if (exportBtn && exportAllMenu && exportAllBtn) {
  // Mostrar men√∫ al hacer clic derecho
  exportBtn.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    showExportAllMenu(e);
  });
  // Mostrar men√∫ al mantener presionado (m√≥vil)
  exportBtn.addEventListener('touchstart', (e) => {
    exportMenuTimeout = setTimeout(() => showExportAllMenu(e), 500);
  });
  exportBtn.addEventListener('touchend', () => {
    clearTimeout(exportMenuTimeout);
  });
  // Ocultar men√∫ al hacer clic fuera
  document.addEventListener('click', (e) => {
    if (!exportAllMenu.contains(e.target) && e.target !== exportBtn) {
      exportAllMenu.classList.add('hidden');
    }
  });
  // Exportar todas
  exportAllBtn.addEventListener('click', async () => {
    exportAllMenu.classList.add('hidden');
    await exportAllReservations();
  });
  // Exportar p√°gina actual (clic normal)
  exportBtn.addEventListener('click', async (e) => {
    if (e.detail === 0) return; // Ignorar si fue touchstart
    await exportToExcel();
  });
}

function showExportAllMenu(e) {
  exportAllMenu.classList.remove('hidden');
  const rect = exportBtn.getBoundingClientRect();
  exportAllMenu.style.top = `${rect.bottom + window.scrollY + 4}px`;
  exportAllMenu.style.left = `${rect.left + window.scrollX}px`;
}

// Exportar todas las reservas del rango/fecha seleccionada
async function exportAllReservations() {
  let queryConstraints = [];

  if (currentPeriodType === 'daily' && currentDateString) {
    queryConstraints.push(where('date', '==', currentDateString));
  } else if (currentPeriodType === 'weekly' && currentDateString) {
    const baseDate = new Date(currentDateString + 'T00:00:00');
    const startOfWeek = new Date(baseDate);
    startOfWeek.setDate(baseDate.getDate() - baseDate.getDay());
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 6);
    const startDate = startOfWeek.toISOString().split('T')[0];
    const endDate = endOfWeek.toISOString().split('T')[0];
    queryConstraints.push(where('date', '>=', startDate));
    queryConstraints.push(where('date', '<=', endDate));
  } else if (currentPeriodType === 'monthly' && currentDateString) {
    const [year, month] = currentDateString.split('-');
    const startDate = `${year}-${month}-01`;
    const lastDay = new Date(year, month, 0).getDate();
    const endDate = `${year}-${month}-${lastDay}`;
    queryConstraints.push(where('date', '>=', startDate));
    queryConstraints.push(where('date', '<=', endDate));
  } else if (currentPeriodType === 'yearly' && currentDateString) {
    const year = currentDateString.substring(0, 4);
    const startDate = `${year}-01-01`;
    const endDate = `${year}-12-31`;
    queryConstraints.push(where('date', '>=', startDate));
    queryConstraints.push(where('date', '<=', endDate));
  } else if (currentPeriodType === 'custom') {
    const dateRangeStart = getEl('dateRangeStart');
    const dateRangeEnd = getEl('dateRangeEnd');
    if (dateRangeStart && dateRangeEnd && dateRangeStart.value && dateRangeEnd.value) {
      queryConstraints.push(where('date', '>=', dateRangeStart.value));
      queryConstraints.push(where('date', '<=', dateRangeEnd.value));
    } else {
      return;
    }
  } else {
    return;
  }

  queryConstraints.push(orderBy('time'));

  const q = query(collection(db, 'reservations'), ...queryConstraints);
  const snapshot = await getDocs(q);
  const reservations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

  exportToExcel(reservations);
}

// Delegaci√≥n de eventos para botones de forzar aprobaci√≥n
document.addEventListener('click', async (e) => {
  const forceApproveBtn = e.target.closest('.force-approve-btn');
  if (forceApproveBtn) {
    const reservationId = forceApproveBtn.dataset.id;
    if (reservationId) {
      const ok = await forcePaymentStatusUpdate(reservationId);
      if (ok) {
        showSuccessModal('Reserva forzada como pagada y confirmada correctamente.');
      } else {
        showSuccessModal('La reserva no existe o ya fue cancelada. Se actualizar√° la lista.');
      }
      // Refrescar la lista de reservas
      const dateFilter = getEl('dateFilter');
      const periodSelector = getEl('periodSelector');
      if (dateFilter && dateFilter.value) {
        fetchAdminReservations(dateFilter.value, periodSelector ? periodSelector.value : 'daily');
      }
    }
  }
});

// ========== NOTIFICACIONES OPTIMIZADAS PARA M√ìVIL (SAMSUNG GALAXY S23) ==========

/**
 * Env√≠a notificaci√≥n optimizada para m√≥vil de nueva reserva
 */
async function sendNewReservationNotification(reservationData) {
    if ('Notification' in window && Notification.permission === 'granted') {
        try {
            const fecha = new Date(reservationData.date + 'T00:00:00').toLocaleDateString('es-AR');
            const montoSenia = reservationData.depositAmount || calcularMontoSenia(reservationData.diners) || 10000;
            let origen = 'Cliente';
            if (reservationData.createdBy === 'admin') origen = 'Admin';
            else if (reservationData.createdBy === 'observador') origen = 'Observador';
            else if (reservationData.createdBy === 'cliente') origen = 'Cliente';
            else if (reservationData.createdBy) origen = reservationData.createdBy;
            let title = `üÜï Nueva Reserva (${origen})`;
            let body = `${reservationData.name || 'Cliente'} - ${reservationData.diners}p - ${fecha} ${reservationData.time} - $${montoSenia.toLocaleString('es-AR')}`;
            if (reservationData.notificationType === 'pending') {
                title = `‚è≥ Reserva pendiente de pago (${origen})`;
                body = `${reservationData.name || 'Cliente'} - ${reservationData.diners}p - ${fecha} ${reservationData.time} - PENDIENTE DE PAGO`;
            } else if (reservationData.notificationType === 'modified') {
                title = `‚úèÔ∏è Reserva Modificada (${origen})`;
                body = `${reservationData.name || 'Cliente'} - ${reservationData.diners}p - ${fecha} ${reservationData.time} - MODIFICADA`;
            }
            const notification = new Notification(title, {
                body: body,
                icon: '/Logo/Logo-Los-Nogales.png',
                badge: '/Logo/favicon-32x32.png',
                tag: 'new-reservation-mobile',
                requireInteraction: true,
                vibrate: [200, 100, 200, 100, 200],
                silent: false, // Sonido activado para m√≥vil
                data: {
                    url: window.location.href,
                    reservationId: reservationData.id,
                    type: 'new_reservation',
                    source: 'admin_mobile',
                    timestamp: Date.now().toString(),
                    priority: 'high'
                }
            });
            notification.onclick = function() {
                window.focus();
                notification.close();
                console.log('üì± [ADMIN_MOBILE] Nueva reserva clickeada:', notification.data.reservationId);
            };
            console.log('‚úÖ [ADMIN_MOBILE] Notificaci√≥n de nueva reserva enviada al m√≥vil');
            return notification;
        } catch (error) {
            console.error('‚ùå [ADMIN_MOBILE] Error enviando notificaci√≥n:', error);
        }
    } else {
        console.warn('‚ö†Ô∏è [ADMIN_MOBILE] Permisos de notificaci√≥n no concedidos');
    }
}

/**
 * Env√≠a notificaci√≥n optimizada para m√≥vil de pago confirmado
 */
async function sendPaymentConfirmedNotification(reservationData) {
    if ('Notification' in window && Notification.permission === 'granted') {
        try {
            const fecha = new Date(reservationData.date + 'T00:00:00').toLocaleDateString('es-AR');
            const montoSenia = reservationData.depositAmount || calcularMontoSenia(reservationData.diners) || 10000;
            let origen = 'Cliente';
            if (reservationData.createdBy === 'admin') origen = 'Admin';
            else if (reservationData.createdBy === 'observador') origen = 'Observador';
            else if (reservationData.createdBy === 'cliente') origen = 'Cliente';
            else if (reservationData.createdBy) origen = reservationData.createdBy;
            
            const notification = new Notification(`üí∞ Pago Confirmado (${origen})`, {
                body: `${reservationData.name || 'Cliente'} - ${reservationData.diners}p - ${fecha} ${reservationData.time} - $${montoSenia.toLocaleString('es-AR')} pagado`,
                icon: '/Logo/Logo-Los-Nogales.png',
                badge: '/Logo/favicon-32x32.png',
                tag: 'payment-confirmed-mobile',
                requireInteraction: false,
                vibrate: [100, 50, 100],
                silent: false,
                data: {
                    url: window.location.href,
                    reservationId: reservationData.id,
                    type: 'payment_confirmed',
                    source: 'admin_mobile',
                    timestamp: Date.now().toString(),
                    priority: 'normal'
                }
            });
            
            notification.onclick = function() {
                window.focus();
                notification.close();
            };
            
            console.log('‚úÖ [ADMIN_MOBILE] Notificaci√≥n de pago confirmado enviada al m√≥vil');
            return notification;
        } catch (error) {
            console.error('‚ùå [ADMIN_MOBILE] Error enviando notificaci√≥n de pago:', error);
        }
    }
}

/**
 * Env√≠a notificaci√≥n optimizada para m√≥vil de recordatorio
 */
async function sendReminderNotification(reservationData, hoursBefore = 24) {
    if ('Notification' in window && Notification.permission === 'granted') {
        try {
            const fecha = new Date(reservationData.date + 'T00:00:00').toLocaleDateString('es-AR');
            const timeText = hoursBefore === 24 ? 'ma√±ana' : 'en 2h';
            const emoji = hoursBefore === 24 ? '‚è∞' : 'üö®';
            let origen = 'Cliente';
            if (reservationData.createdBy === 'admin') origen = 'Admin';
            else if (reservationData.createdBy === 'observador') origen = 'Observador';
            else if (reservationData.createdBy === 'cliente') origen = 'Cliente';
            else if (reservationData.createdBy) origen = reservationData.createdBy;
            
            const notification = new Notification(`${emoji} Recordatorio (${origen})`, {
                body: `${reservationData.name || 'Cliente'} - ${reservationData.diners}p - ${fecha} ${reservationData.time} - ${timeText}`,
                icon: '/Logo/Logo-Los-Nogales.png',
                badge: '/Logo/favicon-32x32.png',
                tag: 'reminder-mobile',
                requireInteraction: true,
                vibrate: [300, 100, 300],
                silent: false,
                data: {
                    url: window.location.href,
                    reservationId: reservationData.id,
                    type: 'reminder',
                    source: 'admin_mobile',
                    timestamp: Date.now().toString(),
                    priority: 'high'
                }
            });
            
            notification.onclick = function() {
                window.focus();
                notification.close();
            };
            
            console.log('‚úÖ [ADMIN_MOBILE] Notificaci√≥n de recordatorio enviada al m√≥vil');
            return notification;
        } catch (error) {
            console.error('‚ùå [ADMIN_MOBILE] Error enviando notificaci√≥n de recordatorio:', error);
        }
    }
}

/**
 * Env√≠a notificaci√≥n optimizada para m√≥vil de cancelaci√≥n
 */
async function sendCancellationNotification(reservationData) {
    if ('Notification' in window && Notification.permission === 'granted') {
        try {
            const fecha = new Date(reservationData.date + 'T00:00:00').toLocaleDateString('es-AR');
            let origen = 'Cliente';
            if (reservationData.createdBy === 'admin') origen = 'Admin';
            else if (reservationData.createdBy === 'observador') origen = 'Observador';
            else if (reservationData.createdBy === 'cliente') origen = 'Cliente';
            else if (reservationData.createdBy) origen = reservationData.createdBy;
            
            const notification = new Notification(`‚ùå Reserva Cancelada (${origen})`, {
                body: `${reservationData.name || 'Cliente'} - ${reservationData.diners}p - ${fecha} ${reservationData.time} - CANCELADA`,
                icon: '/Logo/Logo-Los-Nogales.png',
                badge: '/Logo/favicon-32x32.png',
                tag: 'cancellation-mobile',
                requireInteraction: false,
                vibrate: [500],
                silent: false,
                data: {
                    url: window.location.href,
                    reservationId: reservationData.id,
                    type: 'cancellation',
                    source: 'admin_mobile',
                    timestamp: Date.now().toString(),
                    priority: 'normal'
                }
            });
            
            notification.onclick = function() {
                window.focus();
                notification.close();
            };
            
            console.log('‚úÖ [ADMIN_MOBILE] Notificaci√≥n de cancelaci√≥n enviada al m√≥vil');
            return notification;
        } catch (error) {
            console.error('‚ùå [ADMIN_MOBILE] Error enviando notificaci√≥n de cancelaci√≥n:', error);
        }
    }
}

/**
 * Configuraci√≥n espec√≠fica para notificaciones en segundo plano en Samsung Galaxy
 */
function setupBackgroundNotifications() {
    // Verificar si es Samsung Galaxy
    if (isSamsungGalaxy()) {
        console.log('üì± [SAMSUNG] Configurando notificaciones en segundo plano');
        
        // Solicitar permisos de notificaci√≥n persistente
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    console.log('‚úÖ [SAMSUNG] Permisos de notificaci√≥n concedidos para segundo plano');
                    
                    // Configurar service worker para notificaciones en segundo plano
                    if ('serviceWorker' in navigator) {
                        navigator.serviceWorker.register('/sw.js').then(registration => {
                            console.log('‚úÖ [SAMSUNG] Service Worker registrado para notificaciones en segundo plano');
                        }).catch(error => {
                            console.error('‚ùå [SAMSUNG] Error registrando Service Worker:', error);
                        });
                    }
                }
            });
        }
        
        // Configurar intervalos m√°s frecuentes para Samsung
        setInterval(() => {
            if ('Notification' in window && Notification.permission === 'granted') {
                console.log('üì± [SAMSUNG] Verificando notificaciones en segundo plano...');
                // Aqu√≠ se ejecutar√°n las verificaciones de recordatorios
            }
        }, 15 * 60 * 1000); // Cada 15 minutos en Samsung
    }
}

// ========== SISTEMA DE FILTROS ==========

// Variable global para el filtro actual
let currentFilter = 'all';
let allReservations = []; // Reservas sin filtrar


/**
 * Actualiza el t√≠tulo para mostrar el filtro activo
 */
function updateFilterTitle(filterType) {
  const titleElement = document.getElementById('reservationsListTitle');
  if (titleElement) {
    let filterText = '';
    switch (filterType) {
      case 'almuerzo':
        filterText = ' - Solo Almuerzos';
        break;
      case 'cena':
        filterText = ' - Solo Cenas';
        break;
      default:
        filterText = '';
    }

    titleElement.textContent = `Listado de Reservas${filterText}`;
  }
}

// ========== SISTEMA DE ASISTENCIAS POR TIEMPO ==========

/**
 * Estados de asistencia
 */
const ATTENDANCE_STATUS = {
    PENDING: 'pending',      // Pendiente (antes de la hora)
    PRESENT: 'present',      // Presente
    ABSENT: 'absent',        // Ausente
    CANCELLED: 'cancelled',  // Cancelado
    LATE: 'late'             // Tard√≠a (15+ minutos despu√©s de la hora)
};

/**
 * Colores para los estados de asistencia (para tarjetas completas)
 */
const ATTENDANCE_COLORS = {
    [ATTENDANCE_STATUS.PENDING]: 'border-green-200 bg-green-50',
    [ATTENDANCE_STATUS.PRESENT]: 'border-blue-200 bg-blue-50',
    [ATTENDANCE_STATUS.ABSENT]: 'border-red-200 bg-red-50',
    [ATTENDANCE_STATUS.CANCELLED]: 'border-gray-200 bg-gray-50',
    [ATTENDANCE_STATUS.LATE]: 'border-orange-200 bg-orange-50'
};

/**
 * Configuraci√≥n del timer autom√°tico
 */
const TIMER_CONFIG = {
    LATE_MINUTES: 15, // Minutos despu√©s de la hora de reserva para marcar como tard√≠a
    TURN_END_TIMES: {
        'almuerzo': '16:00', // El almuerzo termina a las 16:00
        'cena': '23:59'      // La cena termina a las 23:59
    }
};

/**
 * Inicializa el sistema de asistencias
 */
function initializeAttendanceSystem() {
    console.log('Inicializando sistema de asistencias...');
    
    // Configurar listeners para botones de asistencia
    setupAttendanceButtons();
    
    // Configurar listener de Firestore para cambios en tiempo real
    // Limpiar listeners anteriores antes de configurar el nuevo
    if (window._firestoreUnsubscribe) {
        window._firestoreUnsubscribe();
        window._firestoreUnsubscribe = null;
    }
    if (window._adminReservationsUnsub) {
        window._adminReservationsUnsub();
        window._adminReservationsUnsub = null;
    }
    
    setupFirestoreListener();
    
    // Solo iniciar timer autom√°tico si es admin
    const isAdmin = currentUserRole === 'admin' || 
                   document.body.classList.contains('admin-mode') ||
                   (typeof window.forceAdminRole === 'function' && window._forceAdminActive);
    
    if (isAdmin) {
        console.log('üëë Iniciando timer autom√°tico como admin...');
        startAutomaticTimer();
    } else {
        console.log('üëÅÔ∏è Timer autom√°tico desactivado para observador');
    }
}

/**
 * Verifica las asistencias bas√°ndose en la hora actual
 */
async function checkAttendanceByTime() {
    try {
        const now = new Date();
        const currentTime = now.toTimeString().slice(0, 5); // HH:MM
        const currentDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
        
        console.log(`Verificando asistencias para ${currentDate} a las ${currentTime}`);
        
        // Obtener reservas del d√≠a actual
        const reservations = await fetchAdminReservations(currentDate, 'daily');
        
        if (!reservations || reservations.length === 0) {
            return;
        }
        
        // Filtrar reservas que deber√≠an estar presentes
        const reservationsToCheck = reservations.filter(res => {
            const reservationTime = res.time;
            const reservationDate = res.date;
            
            // Solo verificar reservas del d√≠a actual
            if (reservationDate !== currentDate) {
                return false;
            }
            
            // Verificar si ya pas√≥ la hora de la reserva (con 15 minutos de tolerancia)
            const reservationDateTime = new Date(`${reservationDate}T${reservationTime}:00`);
            const toleranceTime = new Date(reservationDateTime.getTime() + 15 * 60000); // +15 minutos
            
            return now >= toleranceTime && (!res.attendanceStatus || res.attendanceStatus === ATTENDANCE_STATUS.PENDING);
        });
        
        // Marcar como ausentes las reservas que no est√°n presentes
        for (const reservation of reservationsToCheck) {
            await markAttendanceStatus(reservation.firestoreId || reservation.id, ATTENDANCE_STATUS.ABSENT, 'Sistema autom√°tico');
        }
        
        if (reservationsToCheck.length > 0) {
            console.log(`Marcadas ${reservationsToCheck.length} reservas como ausentes autom√°ticamente`);
            // No hacer refresh autom√°tico, el listener de Firestore se encargar√°
            console.log('Ausencias marcadas, el listener de Firestore actualizar√° la UI');
        }
        
    } catch (error) {
        console.error('Error verificando asistencias:', error);
    }
}

/**
 * Marca el estado de asistencia de una reserva
 */
async function markAttendanceStatus(reservationId, status, reason = 'Admin') {
    // Verificaci√≥n m√°s robusta del rol
    const isAdmin = currentUserRole === 'admin' || 
                   document.body.classList.contains('admin-mode') ||
                   (typeof window.forceAdminRole === 'function' && window._forceAdminActive);
    
    // Verificar que sea admin antes de permitir modificar asistencias
    if (!isAdmin) {
        console.error('Intento de modificar asistencia por usuario no autorizado:', currentUserRole);
        return false;
    }
    
    try {
        const reservationRef = doc(db, "reservations", reservationId);
        
        const updateData = {
            attendanceStatus: status,
            attendanceUpdatedAt: serverTimestamp(),
            attendanceUpdatedBy: reason
        };
        
        // Si est√° ausente, tambi√©n marcar como eliminada
        if (status === ATTENDANCE_STATUS.ABSENT) {
            updateData.status = 'cancelled';
            updateData.cancelledAt = serverTimestamp();
            updateData.cancelledBy = reason;
            
            // Guardar en el historial de cancelaciones ANTES de eliminar
            try {
                // Obtener los datos completos de la reserva
                const reservationDoc = await getDoc(reservationRef);
                if (reservationDoc.exists()) {
                    const reservationData = reservationDoc.data();
                    
                    // Crear registro de cancelaci√≥n
                    const cancellationData = {
                        reservationId: reservationId,
                        name: reservationData.name || '',
                        phone: reservationData.phone || '',
                        date: reservationData.date || '',
                        time: reservationData.time || '',
                        diners: reservationData.diners || '',
                        area: reservationData.area || '',
                        notes: reservationData.notes || '',
                        cancelledAt: new Date().toISOString(),
                        cancelledBy: 'admin',
                        motivo: 'Ausente - Sistema de Asistencias',
                        attendanceStatus: 'absent',
                        // Guardar todos los campos extra de la reserva original
                        ...reservationData
                    };
                    
                    // Guardar en la colecci√≥n de cancelaciones
                    await setDoc(doc(db, "cancellations", reservationId + '_' + Date.now()), cancellationData);
                    console.log(`Reserva ${reservationId} guardada en historial de cancelaciones por ausencia`);
                }
            } catch (error) {
                console.error('Error guardando en historial de cancelaciones:', error);
            }
            
            // Eliminar f√≠sicamente el documento despu√©s de un breve delay
            setTimeout(async () => {
                try {
                    await deleteDoc(reservationRef);
                    console.log(`Reserva ${reservationId} eliminada autom√°ticamente por ausencia`);
                } catch (error) {
                    console.error('Error eliminando reserva por ausencia:', error);
                }
            }, 2000); // 2 segundos de delay para que se vea el cambio
        }
        
        await updateDoc(reservationRef, updateData);
        
        console.log(`Reserva ${reservationId} marcada como ${status} por ${reason}`);
        
        // Actualizar totales si es necesario
        if (status === ATTENDANCE_STATUS.ABSENT) {
            // Si se marca como ausente, actualizar totales despu√©s de un delay
            setTimeout(() => {
                updateTotalsOnly();
            }, 2500); // Despu√©s de que se elimine la reserva
            
            // Enviar notificaci√≥n
            showAttendanceNotification(`Reserva marcada como ausente autom√°ticamente`, 'warning');
        } else {
            // Para otros estados, actualizar totales inmediatamente
            updateTotalsOnly();
        }
        
        return true;
    } catch (error) {
        console.error('Error marcando estado de asistencia:', error);
        return false;
    }
}

/**
 * Configura los botones de asistencia en las tarjetas
 */
function setupAttendanceButtons() {
    // Los botones se configurar√°n din√°micamente cuando se rendericen las tarjetas
    document.addEventListener('click', async (e) => {
        if (e.target.closest('.attendance-btn')) {
            e.preventDefault();
            
            // Verificaci√≥n m√°s robusta del rol
            const isAdmin = currentUserRole === 'admin' || 
                           document.body.classList.contains('admin-mode') ||
                           (typeof window.forceAdminRole === 'function' && window._forceAdminActive);
            
            // Verificar que sea admin antes de permitir acciones
            if (!isAdmin) {
                showAttendanceNotification('Solo los administradores pueden modificar asistencias', 'warning');
                return;
            }
            
            const button = e.target.closest('.attendance-btn');
            const reservationId = button.dataset.reservationId;
            const action = button.dataset.action;
            
            if (!reservationId || !action) {
                console.error('Datos de bot√≥n de asistencia incompletos');
                return;
            }
            
            let status;
            let reason;
            
            switch (action) {
                case 'present':
                    status = ATTENDANCE_STATUS.PRESENT;
                    reason = 'Admin - Presente';
                    break;
                case 'absent':
                    status = ATTENDANCE_STATUS.ABSENT;
                    reason = 'Admin - Ausente';
                    break;
                case 'pending':
                    status = ATTENDANCE_STATUS.PENDING;
                    reason = 'Admin - Pendiente';
                    break;
                case 'late':
                    status = ATTENDANCE_STATUS.LATE;
                    reason = 'Admin - Tard√≠a';
                    break;
                default:
                    console.error('Acci√≥n de asistencia no v√°lida:', action);
                    return;
            }
            
            const success = await markAttendanceStatus(reservationId, status, reason);
            
            if (success) {
                showAttendanceNotification(`Asistencia marcada como ${getAttendanceStatusText(status)}`, 'success');
                // Refrescar la UI
                await forceRefreshReservations();
            } else {
                showAttendanceNotification('Error al marcar asistencia', 'error');
            }
        }
    });
}

/**
 * Obtiene el texto del estado de asistencia
 */
function getAttendanceStatusText(status) {
    // Si no hay estado, retornar string vac√≠o
    if (!status || status === '') {
        return '';
    }
    
    switch (status) {
        case ATTENDANCE_STATUS.PENDING:
            return 'Pendiente';
        case ATTENDANCE_STATUS.PRESENT:
            return 'Presente';
        case ATTENDANCE_STATUS.ABSENT:
            return 'Ausente';
        case ATTENDANCE_STATUS.CANCELLED:
            return 'Cancelado';
        case ATTENDANCE_STATUS.LATE:
            return 'Tard√≠a';
        default:
            return 'Desconocido';
    }
}

/**
 * Obtiene el color del estado de asistencia
 */
function getAttendanceStatusColor(status) {
    // Si no hay estado o es null/undefined, no aplicar color
    if (!status || status === '') {
        return '';
    }
    return ATTENDANCE_COLORS[status] || '';
}

/**
 * Muestra notificaciones de asistencia
 */
function showAttendanceNotification(message, type = 'info') {
    const notificationDiv = document.createElement('div');
    notificationDiv.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-sm transition-all duration-300 transform translate-x-full`;
    
    let bgColor, textColor, icon;
    
    switch (type) {
        case 'success':
            bgColor = 'bg-green-500';
            textColor = 'text-white';
            icon = 'ph-check-circle';
            break;
        case 'warning':
            bgColor = 'bg-yellow-500';
            textColor = 'text-white';
            icon = 'ph-warning';
            break;
        case 'error':
            bgColor = 'bg-red-500';
            textColor = 'text-white';
            icon = 'ph-x-circle';
            break;
        default:
            bgColor = 'bg-blue-500';
            textColor = 'text-white';
            icon = 'ph-info';
    }
    
    notificationDiv.innerHTML = `
        <div class="flex items-center space-x-3">
            <i class="${icon} text-xl"></i>
            <span class="font-medium">${message}</span>
        </div>
    `;
    
    notificationDiv.classList.add(bgColor, textColor);
    
    document.body.appendChild(notificationDiv);
    
    // Animar entrada
    setTimeout(() => {
        notificationDiv.classList.remove('translate-x-full');
    }, 100);
    
    // Auto-remover despu√©s de 3 segundos
    setTimeout(() => {
        notificationDiv.classList.add('translate-x-full');
        setTimeout(() => {
            if (notificationDiv.parentNode) {
                notificationDiv.parentNode.removeChild(notificationDiv);
            }
        }, 300);
    }, 3000);
}

/**
 * Genera los botones de asistencia para una reserva
 */
function generateAttendanceButtons(reservation) {
    const currentStatus = reservation.attendanceStatus || '';
    const reservationId = reservation.firestoreId || reservation.id;
    
    // Verificaci√≥n m√°s robusta del rol
    const isAdmin = currentUserRole === 'admin' || 
                   document.body.classList.contains('admin-mode') ||
                   (typeof window.forceAdminRole === 'function' && window._forceAdminActive);
    
    // Debug: mostrar el rol actual
    console.log('üîç Debug - Rol actual:', currentUserRole, 'Tipo:', typeof currentUserRole, '¬øEs admin?:', isAdmin);
    
    // Solo mostrar botones si es admin, no para observador
    if (!isAdmin) {
        console.log('üö´ Usuario no es admin, mostrando solo visualizaci√≥n');
        // Para observador, mostrar solo texto informativo
        return `
            <div class="text-xs text-gray-500 mt-2 italic">
                <i class="ph ph-eye mr-1"></i>Solo visualizaci√≥n (Rol: ${currentUserRole || 'null'})
            </div>
        `;
    }
    
    const buttons = [];
    
    // Bot√≥n Presente
    const presentActive = currentStatus === ATTENDANCE_STATUS.PRESENT ? 'bg-blue-500 text-white' : 'bg-blue-100 text-blue-700 hover:bg-blue-200';
    buttons.push(`
        <button data-reservation-id="${reservationId}" data-action="present" 
                class="attendance-btn px-3 py-1 rounded-full text-xs font-medium transition-colors ${presentActive}">
            <i class="ph ph-check mr-1"></i>Presente
        </button>
    `);
    
    // Bot√≥n Ausente
    const absentActive = currentStatus === ATTENDANCE_STATUS.ABSENT ? 'bg-red-500 text-white' : 'bg-red-100 text-red-700 hover:bg-red-200';
    buttons.push(`
        <button data-reservation-id="${reservationId}" data-action="absent" 
                class="attendance-btn px-3 py-1 rounded-full text-xs font-medium transition-colors ${absentActive}">
            <i class="ph ph-x mr-1"></i>Ausente
        </button>
    `);
    
    // Bot√≥n Pendiente
    const pendingActive = currentStatus === ATTENDANCE_STATUS.PENDING ? 'bg-green-500 text-white' : 'bg-green-100 text-green-700 hover:bg-green-200';
    buttons.push(`
        <button data-reservation-id="${reservationId}" data-action="pending" 
                class="attendance-btn px-3 py-1 rounded-full text-xs font-medium transition-colors ${pendingActive}">
            <i class="ph ph-clock mr-1"></i>Pendiente
        </button>
    `);
    
    // Bot√≥n Tard√≠a
    const lateActive = currentStatus === ATTENDANCE_STATUS.LATE ? 'bg-orange-500 text-white' : 'bg-orange-100 text-orange-700 hover:bg-orange-200';
    buttons.push(`
        <button data-reservation-id="${reservationId}" data-action="late" 
                class="attendance-btn px-3 py-1 rounded-full text-xs font-medium transition-colors ${lateActive}">
            <i class="ph ph-clock-countdown mr-1"></i>Tard√≠a
        </button>
    `);
    
    return buttons.join('');
}

// ========== FUNCIONES DE FILTROS ==========

/**
 * Configura los filtros por turno
 */
function setupTurnFilters() {
    document.addEventListener('click', (e) => {
        if (e.target.closest('.filter-card')) {
            const filterCard = e.target.closest('.filter-card');
            const filterType = filterCard.dataset.filter;
            
            if (filterType) {
                applyFilter(filterType);
            }
        }
    });
}

/**
 * Actualiza los estilos de las tarjetas de filtro
 */
function updateFilterCardStyles(activeFilter) {
    // Remover estilos activos de todas las tarjetas
    document.querySelectorAll('.filter-card').forEach(card => {
        card.classList.remove('ring-2', 'ring-blue-500', 'bg-blue-50');
        
        // Restaurar colores originales
        if (card.dataset.filter === 'all') {
            card.classList.remove('bg-gray-200');
            card.classList.add('bg-gray-100');
        } else {
            card.classList.remove('bg-green-100');
            card.classList.add('bg-green-50');
        }
    });
    
    // Aplicar estilo activo a la tarjeta seleccionada
    const activeCard = document.querySelector(`[data-filter="${activeFilter}"]`);
    if (activeCard) {
        activeCard.classList.add('ring-2', 'ring-blue-500');
        
        if (activeFilter === 'all') {
            activeCard.classList.remove('bg-gray-100');
            activeCard.classList.add('bg-blue-50');
        } else {
            activeCard.classList.remove('bg-green-50');
            activeCard.classList.add('bg-blue-50');
        }
    }
}

/**
 * Filtra las reservas para exportar a Excel seg√∫n el filtro actual
 */
function getFilteredReservationsForExport() {
    if (currentFilter === 'all') {
        return allReservations;
    } else {
        return allReservations.filter(reservation => {
            const turn = reservation.turn || calcularTurnoPorHora(reservation.time);
            return turn.toLowerCase() === currentFilter.toLowerCase();
        });
    }
}

// ========== FUNCIONES DE LIMPIEZA Y ESTADO ==========

/**
 * Limpia el estado del sistema
 */
function clearSystemState() {
    currentFilter = 'all';
    allReservations = [];
    console.log('üßπ Estado del sistema limpiado');
}

/**
 * Limpia el listener de Firestore
 */
function cleanupFirestoreListener() {
    if (window._firestoreUnsubscribe) {
        window._firestoreUnsubscribe();
        window._firestoreUnsubscribe = null;
        console.log('üîá Listener de Firestore limpiado');
    }
}

/**
 * Limpia todos los timers y listeners
 */
function cleanupAllTimers() {
    // Limpiar timer autom√°tico
    if (window._automaticTimer) {
        clearInterval(window._automaticTimer);
        window._automaticTimer = null;
        console.log('‚è∞ Timer autom√°tico limpiado');
    }
    
    // Limpiar listener de Firestore
    cleanupFirestoreListener();
    
    // Limpiar flags de actualizaci√≥n
    window._isUpdatingFromListener = false;
    
    console.log('üßπ Todos los timers y listeners limpiados');
}

/**
 * Reinicializa el sistema despu√©s de cambios
 */
function reinitializeSystem() {
    clearSystemState();
    
    // Limpiar todos los timers y listeners
    cleanupAllTimers();
    
    // Resetear estilos de filtros
    updateFilterCardStyles('all');
    
    // Limpiar t√≠tulo
    const titleElement = document.getElementById('reservationsListTitle');
    if (titleElement) {
        titleElement.textContent = 'Listado de Reservas';
    }
    
    // Reconfigurar listener
    setupFirestoreListener();
    
    console.log('üîÑ Sistema reinicializado');
}

/**
 * Actualiza solo los totales sin refrescar toda la UI
 */
function updateTotalsOnly() {
    if (allReservations.length === 0) return;
    
    let totalDinersDay = 0, totalDinersLunch = 0, totalDinersDinner = 0;
    
    allReservations.forEach(res => {
        const d = parseInt(res.diners) || 0;
        const turn = res.turn || calcularTurnoPorHora(res.time);
        totalDinersDay += d;
        if (turn.toLowerCase() === 'almuerzo') totalDinersLunch += d;
        else if (turn.toLowerCase() === 'cena') totalDinersDinner += d;
    });
    
    // Actualizar solo los n√∫meros, manteniendo los t√≠tulos
    const totalPeriodElement = getEl('totalDinersPeriod');
    const totalLunchElement = getEl('totalDinersLunch');
    const totalDinnerElement = getEl('totalDinersDinner');
    
    if (totalPeriodElement) {
        const numberElement = totalPeriodElement.querySelector('p');
        if (numberElement) {
            numberElement.textContent = totalDinersDay;
        }
    }
    
    if (totalLunchElement) {
        const numberElement = totalLunchElement.querySelector('p');
        if (numberElement) {
            numberElement.textContent = totalDinersLunch;
        }
    }
    
    if (totalDinnerElement) {
        const numberElement = totalDinnerElement.querySelector('p');
        if (numberElement) {
            numberElement.textContent = totalDinersDinner;
        }
    }
    
    console.log(`üìä Totales actualizados: ${totalDinersDay} total, ${totalDinersLunch} almuerzos, ${totalDinersDinner} cenas`);
}

/**
 * Configura el listener de Firestore para cambios en tiempo real
 */
function setupFirestoreListener() {
    console.log('üîî Configurando listener de Firestore para cambios en tiempo real...');
    
    // Usar listener simple por defecto para evitar problemas de √≠ndices
    setupSimpleFirestoreListener();
}

/**
 * Configura un listener de Firestore m√°s simple sin √≠ndices
 */
function setupSimpleFirestoreListener() {
    console.log('üîî Configurando listener simple de Firestore...');
    
    // Verificar si ya hay un listener activo
    if (window._firestoreUnsubscribe) {
        console.log('üîá Limpiando listener anterior...');
        window._firestoreUnsubscribe();
        window._firestoreUnsubscribe = null;
    }
    
    try {
        // Listener simple para toda la colecci√≥n
        const reservationsRef = collection(db, "reservations");
        const unsubscribe = onSnapshot(reservationsRef, (snapshot) => {
            console.log('üîÑ Cambios detectados en Firestore (listener simple)');
            
            const changes = snapshot.docChanges();
            let hasRelevantChanges = false;
            
            changes.forEach((change) => {
                if (change.type === 'added' || change.type === 'modified' || change.type === 'removed') {
                    console.log(`üìù Cambio detectado: ${change.type} - ${change.doc.id}`);
                    hasRelevantChanges = true;
                }
            });
            
            if (hasRelevantChanges) {
                console.log('üîÑ Actualizando UI por cambios en tiempo real...');
                
                // Verificar asistencias si es necesario
                checkAttendanceByTime();
                
                // Actualizar la UI solo si no hay filtro activo o si es el filtro "all"
                if (currentFilter === 'all' || currentFilter === '') {
                    // NO llamar a fetchAdminReservations porque crea un nuevo listener
                    // En su lugar, usar el listener existente para obtener datos actualizados
                    const dateFilter = getEl('dateFilter');
                    if (dateFilter && dateFilter.value) {
                        // Guardar el estado actual de allReservations
                        const currentAllReservations = [...allReservations];
                        console.log(`üíæ Guardando ${currentAllReservations.length} reservas antes de actualizar`);
                        
                        // Usar un flag para evitar m√∫ltiples actualizaciones simult√°neas
                        if (window._isUpdatingFromListener) {
                            console.log('‚è≥ Actualizaci√≥n ya en progreso, saltando...');
                            return;
                        }
                        
                        window._isUpdatingFromListener = true;
                        
                        // En lugar de fetchAdminReservations, usar una consulta directa
                        const currentDate = dateFilter.value;
                        const reservationsRef = collection(db, "reservations");
                        const q = query(reservationsRef, where('date', '==', currentDate));
                        
                        getDocs(q).then((snapshot) => {
                            const reservations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            const filteredReservations = reservations.filter(res => res.name && res.date && res.time);
                            filteredReservations.sort((a, b) => {
                                const dateA = new Date(`${a.date}T${a.time}`);
                                const dateB = new Date(`${b.date}T${b.time}`);
                                return dateA - dateB;
                            });
                            
                            // Actualizar UI con los datos frescos pero preservar allReservations
                            updateAdminUI(filteredReservations, 'FILTER_UPDATE', 'Actualizaci√≥n en tiempo real');
                            
                            // Restaurar allReservations despu√©s de un breve delay
                            setTimeout(() => {
                                if (currentAllReservations.length > 0) {
                                    allReservations = currentAllReservations;
                                    console.log(`üîÑ Restauradas ${allReservations.length} reservas para filtros`);
                                    
                                    // Verificar que los filtros est√©n funcionando
                                    if (currentFilter && currentFilter !== 'all') {
                                        console.log(`üîÑ Reaplicando filtro: ${currentFilter}`);
                                        applyFilter(currentFilter);
                                    }
                                }
                                window._isUpdatingFromListener = false;
                            }, 100);
                        }).catch((error) => {
                            console.error('Error obteniendo datos actualizados:', error);
                            window._isUpdatingFromListener = false;
                        });
                    }
                } else {
                    // Solo actualizar totales si hay filtro activo
                    updateTotalsOnly();
                }
            }
        }, (error) => {
            console.error('‚ùå Error en listener simple de Firestore:', error);
            // Si hay error, desactivar el listener
            if (window._firestoreUnsubscribe) {
                window._firestoreUnsubscribe();
                window._firestoreUnsubscribe = null;
            }
        });
        
        // Guardar la funci√≥n de unsubscribe
        window._firestoreUnsubscribe = unsubscribe;
        
        console.log('‚úÖ Listener simple de Firestore configurado');
    } catch (error) {
        console.error('‚ùå Error configurando listener de Firestore:', error);
    }
}

/**
 * Timer autom√°tico para gestionar reservas tard√≠as y eliminaci√≥n al final del turno
 */
async function startAutomaticTimer() {
    console.log('‚è∞ Iniciando timer autom√°tico para reservas...');
    
    // Verificar que sea admin antes de iniciar
    const isAdmin = currentUserRole === 'admin' || 
                   document.body.classList.contains('admin-mode') ||
                   (typeof window.forceAdminRole === 'function' && window._forceAdminActive);
    
    if (!isAdmin) {
        console.log('üö´ Timer autom√°tico solo disponible para admin');
        return;
    }
    
    // Limpiar timer anterior si existe
    if (window._automaticTimer) {
        clearInterval(window._automaticTimer);
    }
    
    // Verificar cada minuto
    window._automaticTimer = setInterval(async () => {
        try {
            await checkLateReservations();
            await checkTurnEndReservations();
        } catch (error) {
            console.error('‚ùå Error en timer autom√°tico:', error);
        }
    }, 60000); // 1 minuto
    
    // Verificar inmediatamente al iniciar
    try {
        await checkLateReservations();
        await checkTurnEndReservations();
    } catch (error) {
        console.error('‚ùå Error en verificaci√≥n inicial del timer:', error);
    }
}

/**
 * Verifica reservas tard√≠as (15+ minutos despu√©s de la hora)
 */
async function checkLateReservations() {
    try {
        const now = new Date();
        const currentDate = now.toISOString().split('T')[0];
        
        // Obtener reservas del d√≠a actual
        const reservations = await fetchAdminReservations(currentDate, 'daily');
        
        if (!reservations || reservations.length === 0) return;
        
        const lateReservations = reservations.filter(res => {
            // Solo verificar reservas pendientes o sin estado
            if (res.attendanceStatus && res.attendanceStatus !== ATTENDANCE_STATUS.PENDING) {
                return false;
            }
            
            // Verificar si ya pas√≥ la hora + 15 minutos
            const reservationTime = res.time;
            const reservationDateTime = new Date(`${currentDate}T${reservationTime}:00`);
            const lateTime = new Date(reservationDateTime.getTime() + TIMER_CONFIG.LATE_MINUTES * 60000);
            
            return now >= lateTime;
        });
        
        // Marcar como tard√≠as
        for (const reservation of lateReservations) {
            await markReservationAsLate(reservation);
        }
        
        if (lateReservations.length > 0) {
            console.log(`‚è∞ Marcadas ${lateReservations.length} reservas como tard√≠as`);
        }
        
    } catch (error) {
        console.error('Error verificando reservas tard√≠as:', error);
    }
}

/**
 * Verifica reservas para eliminar al final del turno
 */
async function checkTurnEndReservations() {
    try {
        const now = new Date();
        const currentTime = now.toTimeString().slice(0, 5); // HH:MM
        const currentDate = now.toISOString().split('T')[0];
        
        // Obtener reservas del d√≠a actual
        const reservations = await fetchAdminReservations(currentDate, 'daily');
        
        if (!reservations || reservations.length === 0) return;
        
        const reservationsToDelete = reservations.filter(res => {
            // Solo verificar reservas tard√≠as o ausentes
            if (res.attendanceStatus !== ATTENDANCE_STATUS.LATE && res.attendanceStatus !== ATTENDANCE_STATUS.ABSENT) {
                return false;
            }
            
            // Verificar si ya termin√≥ el turno
            const turn = res.turn || calcularTurnoPorHora(res.time);
            const turnEndTime = TIMER_CONFIG.TURN_END_TIMES[turn.toLowerCase()];
            
            if (!turnEndTime) return false;
            
            return currentTime >= turnEndTime;
        });
        
        // Eliminar reservas al final del turno
        for (const reservation of reservationsToDelete) {
            await deleteReservationAtTurnEnd(reservation);
        }
        
        if (reservationsToDelete.length > 0) {
            console.log(`üóëÔ∏è Eliminadas ${reservationsToDelete.length} reservas al final del turno`);
        }
        
    } catch (error) {
        console.error('Error verificando fin de turno:', error);
    }
}

/**
 * Marca una reserva como tard√≠a
 */
async function markReservationAsLate(reservation) {
    try {
        const reservationRef = doc(db, "reservations", reservation.firestoreId || reservation.id);
        
        await updateDoc(reservationRef, {
            attendanceStatus: ATTENDANCE_STATUS.LATE,
            attendanceUpdatedAt: serverTimestamp(),
            attendanceUpdatedBy: 'Sistema autom√°tico - Tard√≠a',
            markedLateAt: serverTimestamp()
        });
        
        console.log(`‚è∞ Reserva ${reservation.firestoreId} marcada como tard√≠a`);
        
        // Enviar notificaci√≥n
        showAttendanceNotification(`Reserva de ${reservation.name} marcada como tard√≠a`, 'warning');
        
    } catch (error) {
        console.error('Error marcando reserva como tard√≠a:', error);
    }
}

/**
 * Elimina una reserva al final del turno
 */
async function deleteReservationAtTurnEnd(reservation) {
    try {
        const reservationRef = doc(db, "reservations", reservation.firestoreId || reservation.id);
        
        // Guardar en historial antes de eliminar
        const cancellationData = {
            reservationId: reservation.firestoreId || reservation.id,
            name: reservation.name || '',
            phone: reservation.phone || '',
            date: reservation.date || '',
            time: reservation.time || '',
            diners: reservation.diners || '',
            area: reservation.area || '',
            notes: reservation.notes || '',
            cancelledAt: new Date().toISOString(),
            cancelledBy: 'sistema',
            motivo: 'Eliminaci√≥n autom√°tica al final del turno',
            attendanceStatus: reservation.attendanceStatus,
            turn: reservation.turn || calcularTurnoPorHora(reservation.time),
            // Guardar todos los campos extra
            ...reservation
        };
        
        // Guardar en historial
        await setDoc(doc(db, "cancellations", reservation.firestoreId + '_turnend_' + Date.now()), cancellationData);
        
        // Eliminar la reserva
        await deleteDoc(reservationRef);
        
        console.log(`üóëÔ∏è Reserva ${reservation.firestoreId} eliminada al final del turno`);
        
        // Enviar notificaci√≥n
        showAttendanceNotification(`Reserva de ${reservation.name} eliminada al final del turno`, 'info');
        
    } catch (error) {
        console.error('Error eliminando reserva al final del turno:', error);
    }
}

// Utilidad para obtener la fecha local en formato YYYY-MM-DD (zona horaria Argentina)
function getLocalDateString() {
    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    return now.toISOString().slice(0, 10);
}

function getTomorrowLocalDateString() {
    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    now.setDate(now.getDate() + 1);
    return now.toISOString().slice(0, 10);
}

// ========== TIMERS INDIVIDUALES POR RESERVA ==========
window.reservationTimers = {};

function setupReservationTimers(reservas) {
    // Limpiar timers anteriores
    for (const id in window.reservationTimers) {
        clearTimeout(window.reservationTimers[id]);
    }
    window.reservationTimers = {};
    
    reservas.forEach(res => {
        if (res.attendanceStatus === 'pending' || !res.attendanceStatus) {
            // Calcular el tiempo hasta 15 minutos despu√©s de la hora de la reserva
            const [hour, minute] = res.time.split(':').map(Number);
            const reservaDate = new Date(res.date + 'T' + res.time);
            const targetTime = new Date(reservaDate.getTime() + 15 * 60000); // +15 minutos
            const now = new Date();
            const msToAbsent = targetTime - now;
            if (msToAbsent > 0) {
                window.reservationTimers[res.id] = setTimeout(() => {
                    // Solo marcar como ausente si sigue pendiente
                    if (!res.attendanceStatus || res.attendanceStatus === 'pending') {
                        markAttendanceStatus(res.id, 'absent', 'Autom√°tico por horario');
                    }
                }, msToAbsent);
            }
        }
    });
}

// Llamar a setupReservationTimers cada vez que se cargan o actualizan reservas
// Por ejemplo, al final de updateAdminUI:
// ... existing code ...
// updateAdminUI(...)
setupReservationTimers(reservations);
// ... existing code ...

// Al marcar asistencia manualmente, cancelar el timer de esa reserva
// En la funci√≥n que maneja el click/manual attendance:
// ... existing code ...
if (window.reservationTimers[reservationId]) {
    clearTimeout(window.reservationTimers[reservationId]);
    delete window.reservationTimers[reservationId];
}
// ... existing code ...

// Eliminar cualquier setInterval o debug autom√°tico global relacionado con asistencia
// ... existing code ...

// Refuerzo: asegurar que los filtros de Total, Almuerzo y Cena nunca se borren ni se re-rendericen
function ensureFilterTitles() {
    // Si los t√≠tulos de los filtros no est√°n, restaurarlos
    const lunchTitle = document.getElementById('lunchTurnTitle');
    const dinnerTitle = document.getElementById('dinnerTurnTitle');
    if (lunchTitle && lunchTitle.textContent.trim() === '') {
        lunchTitle.textContent = 'Total Almuerzos';
    }
    if (dinnerTitle && dinnerTitle.textContent.trim() === '') {
        dinnerTitle.textContent = 'Total Cenas';
    }
    // Total Comensales
    const totalDinersPeriod = document.getElementById('totalDinersPeriod');
    if (totalDinersPeriod && !totalDinersPeriod.querySelector('h3')) {
        totalDinersPeriod.innerHTML = '<h3 class="font-bold text-gray-600">Total Comensales <span id="periodDisplay"></span></h3><p class="text-4xl font-extrabold text-gray-800">0</p>';
    }
}

// Llamar a ensureFilterTitles al aplicar filtro y al actualizar estilos
// ‚úÖ Reemplazo de estilos al aplicar filtros
const originalUpdateFilterCardStyles = updateFilterCardStyles;
updateFilterCardStyles = function (activeFilter) {
    originalUpdateFilterCardStyles(activeFilter);
    ensureFilterTitles(); // Asegura que los t√≠tulos est√©n actualizados
};

// ‚úÖ Funci√≥n para limpiar la UI sin eliminar toda la estructura
function clearReservationsUI() {
    const body = getEl('reservationsTableBody');
    if (body) {
        body.querySelectorAll('tr').forEach(row => {
            if (row.textContent.includes('Cargando reservas...')) {
                row.remove();
            }
        });
    }

    const mobileDiv = getEl('reservasCardsMobile');
    if (mobileDiv && mobileDiv.innerHTML.includes('Cargando reservas...')) {
        mobileDiv.innerHTML = '';
    }
}

// ‚úÖ Fuente de verdad: reservas por fecha
let reservasPorFecha = {};
let currentDate = '';

// ‚úÖ Cambiar fecha: guarda reservas y aplica filtro actual
function onDateChange(newDate, reservasDeLaFecha) {
    currentDate = newDate;
    reservasPorFecha[currentDate] = reservasDeLaFecha;
    applyFilter(currentFilter); // se mantiene el filtro actual
}

// ‚úÖ Aplicar filtros sin modificar la fecha ni recargar desde cero
function applyFilter(filterType) {
    const reservasFecha = reservasPorFecha[currentDate] || [];

    const filteredReservations = (filterType.toLowerCase() === 'all')
        ? reservasFecha
        : reservasFecha.filter(res => {
            const turn = (res.turn || calcularTurnoPorHora(res.time) || '').toLowerCase();
            return turn === filterType.toLowerCase();
        });

    // Actualiza UI y totales
    updateAdminUI(filteredReservations, 'FILTER_UPDATE', '');
    updateTotalsWithFiltered(filteredReservations);
    updateFilterCardStyles(filterType);
    updateFilterTitle(filterType);
    ensureFilterTitles();

    currentFilter = filterType; // Guardamos el filtro actual
}

// ‚úÖ Actualizar totales con los datos filtrados
function updateTotalsWithFiltered(reservations) {
    let dinersDay = 0, dinersLunch = 0, dinersDinner = 0;

    reservations.forEach(res => {
        const diners = parseInt(res.diners) || 0;
        const turn = (res.turn || calcularTurnoPorHora(res.time) || '').toLowerCase();

        dinersDay += diners;
        if (turn === 'almuerzo') dinersLunch += diners;
        else if (turn === 'cena') dinersDinner += diners;
    });

    updateDinerElement('totalDinersPeriod', dinersDay);
    updateDinerElement('totalDinersLunch', dinersLunch);
    updateDinerElement('totalDinersDinner', dinersDinner);
}

// ‚úÖ Reutilizable para actualizar totales
function updateDinerElement(elementId, value) {
    const el = document.getElementById(elementId);
    if (el) {
        const p = el.querySelector('p');
        if (p) p.textContent = value;
    }
}

// ... existing code ...
// ‚úÖ Definir setupAddReservationButton si no existe
function setupAddReservationButton() {
    const addReservationBtn = getEl('add-reservation-button');
    if (addReservationBtn) {
        addReservationBtn.onclick = () => {
            openAddReservationModal();
        };
    }
    // Event listener para cerrar el modal desde el HTML
    const closeAddReservationModal = getEl('closeAddReservationModal');
    if (closeAddReservationModal) {
        closeAddReservationModal.onclick = () => {
            const modal = getEl('add-reservation-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
        };
    }
}
// ... existing code ...
// ‚úÖ Corregir uso de 'reservations' en la l√≠nea 3935
// Busca y reemplaza cualquier uso de 'reservations' en esa zona por el array correcto, por ejemplo:
// filteredReservations, reservasPorFecha[currentDate], o el que corresponda
// ... existing code ...